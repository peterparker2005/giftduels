// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDuel = `-- name: CreateDuel :one
INSERT INTO duels (is_private, max_players, max_gifts)
VALUES ($1, $2, $3)
RETURNING id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, status, created_at, updated_at, completed_at
`

type CreateDuelParams struct {
	IsPrivate  bool
	MaxPlayers int32
	MaxGifts   int32
}

func (q *Queries) CreateDuel(ctx context.Context, arg CreateDuelParams) (Duel, error) {
	row := q.db.QueryRow(ctx, createDuel, arg.IsPrivate, arg.MaxPlayers, arg.MaxGifts)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.DisplayNumber,
		&i.IsPrivate,
		&i.MaxPlayers,
		&i.MaxGifts,
		&i.WinnerTelegramUserID,
		&i.NextRollDeadline,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createParticipant = `-- name: CreateParticipant :one
INSERT INTO duel_participants (duel_id, telegram_user_id, is_creator)
VALUES ($1, $2, $3)
RETURNING duel_id, telegram_user_id, is_creator
`

type CreateParticipantParams struct {
	DuelID         pgtype.UUID
	TelegramUserID int64
	IsCreator      bool
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) (DuelParticipant, error) {
	row := q.db.QueryRow(ctx, createParticipant, arg.DuelID, arg.TelegramUserID, arg.IsCreator)
	var i DuelParticipant
	err := row.Scan(&i.DuelID, &i.TelegramUserID, &i.IsCreator)
	return i, err
}

const createRoll = `-- name: CreateRoll :one
INSERT INTO duel_rolls (duel_id, round_number, telegram_user_id, dice_value, rolled_at, is_auto_rolled, telegram_message_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING duel_id, round_number, telegram_user_id, dice_value, rolled_at, is_auto_rolled, telegram_message_id
`

type CreateRollParams struct {
	DuelID            pgtype.UUID
	RoundNumber       int32
	TelegramUserID    int64
	DiceValue         int16
	RolledAt          pgtype.Timestamptz
	IsAutoRolled      bool
	TelegramMessageID int32
}

func (q *Queries) CreateRoll(ctx context.Context, arg CreateRollParams) (DuelRoll, error) {
	row := q.db.QueryRow(ctx, createRoll,
		arg.DuelID,
		arg.RoundNumber,
		arg.TelegramUserID,
		arg.DiceValue,
		arg.RolledAt,
		arg.IsAutoRolled,
		arg.TelegramMessageID,
	)
	var i DuelRoll
	err := row.Scan(
		&i.DuelID,
		&i.RoundNumber,
		&i.TelegramUserID,
		&i.DiceValue,
		&i.RolledAt,
		&i.IsAutoRolled,
		&i.TelegramMessageID,
	)
	return i, err
}

const createRound = `-- name: CreateRound :one
INSERT INTO duel_rounds (duel_id, round_number)
VALUES ($1, $2)
RETURNING duel_id, round_number
`

type CreateRoundParams struct {
	DuelID      pgtype.UUID
	RoundNumber int32
}

func (q *Queries) CreateRound(ctx context.Context, arg CreateRoundParams) (DuelRound, error) {
	row := q.db.QueryRow(ctx, createRound, arg.DuelID, arg.RoundNumber)
	var i DuelRound
	err := row.Scan(&i.DuelID, &i.RoundNumber)
	return i, err
}

const createStake = `-- name: CreateStake :one
INSERT INTO duel_stakes (duel_id, telegram_user_id, gift_id)
VALUES ($1, $2, $3)
RETURNING duel_id, telegram_user_id, gift_id
`

type CreateStakeParams struct {
	DuelID         pgtype.UUID
	TelegramUserID int64
	GiftID         pgtype.UUID
}

func (q *Queries) CreateStake(ctx context.Context, arg CreateStakeParams) (DuelStake, error) {
	row := q.db.QueryRow(ctx, createStake, arg.DuelID, arg.TelegramUserID, arg.GiftID)
	var i DuelStake
	err := row.Scan(&i.DuelID, &i.TelegramUserID, &i.GiftID)
	return i, err
}

const findDueDuels = `-- name: FindDueDuels :many
SELECT id FROM duels
WHERE status = 'in_progress'
  AND next_roll_deadline <= $1
`

func (q *Queries) FindDueDuels(ctx context.Context, nextRollDeadline pgtype.Timestamptz) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, findDueDuels, nextRollDeadline)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findDuelByGiftID = `-- name: FindDuelByGiftID :one
SELECT d.id
FROM duels d
JOIN duel_stakes s ON s.duel_id = d.id
WHERE s.gift_id = $1
ORDER BY d.created_at DESC
LIMIT 1
`

func (q *Queries) FindDuelByGiftID(ctx context.Context, giftID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, findDuelByGiftID, giftID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const get1v1Duels = `-- name: Get1v1Duels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, status, created_at, updated_at, completed_at FROM duels
WHERE status IN ('waiting_for_opponent', 'in_progress')
  AND max_players = 2
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type Get1v1DuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) Get1v1Duels(ctx context.Context, arg Get1v1DuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, get1v1Duels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1v1DuelsCount = `-- name: Get1v1DuelsCount :one
SELECT COUNT(*) FROM duels
WHERE status IN ('waiting_for_opponent', 'in_progress')
  AND max_players = 2
`

func (q *Queries) Get1v1DuelsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, get1v1DuelsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDuelByID = `-- name: GetDuelByID :one
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, status, created_at, updated_at, completed_at FROM duels WHERE id = $1
`

func (q *Queries) GetDuelByID(ctx context.Context, id pgtype.UUID) (Duel, error) {
	row := q.db.QueryRow(ctx, getDuelByID, id)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.DisplayNumber,
		&i.IsPrivate,
		&i.MaxPlayers,
		&i.MaxGifts,
		&i.WinnerTelegramUserID,
		&i.NextRollDeadline,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getDuelParticipants = `-- name: GetDuelParticipants :many
SELECT duel_id, telegram_user_id, is_creator FROM duel_participants WHERE duel_id = $1
`

func (q *Queries) GetDuelParticipants(ctx context.Context, duelID pgtype.UUID) ([]DuelParticipant, error) {
	rows, err := q.db.Query(ctx, getDuelParticipants, duelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuelParticipant
	for rows.Next() {
		var i DuelParticipant
		if err := rows.Scan(&i.DuelID, &i.TelegramUserID, &i.IsCreator); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDuelRolls = `-- name: GetDuelRolls :many
SELECT duel_id, round_number, telegram_user_id, dice_value, rolled_at, is_auto_rolled, telegram_message_id FROM duel_rolls WHERE duel_id = $1 ORDER BY round_number, rolled_at
`

func (q *Queries) GetDuelRolls(ctx context.Context, duelID pgtype.UUID) ([]DuelRoll, error) {
	rows, err := q.db.Query(ctx, getDuelRolls, duelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuelRoll
	for rows.Next() {
		var i DuelRoll
		if err := rows.Scan(
			&i.DuelID,
			&i.RoundNumber,
			&i.TelegramUserID,
			&i.DiceValue,
			&i.RolledAt,
			&i.IsAutoRolled,
			&i.TelegramMessageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDuelRounds = `-- name: GetDuelRounds :many
SELECT duel_id, round_number FROM duel_rounds WHERE duel_id = $1 ORDER BY round_number
`

func (q *Queries) GetDuelRounds(ctx context.Context, duelID pgtype.UUID) ([]DuelRound, error) {
	rows, err := q.db.Query(ctx, getDuelRounds, duelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuelRound
	for rows.Next() {
		var i DuelRound
		if err := rows.Scan(&i.DuelID, &i.RoundNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDuelStakes = `-- name: GetDuelStakes :many
SELECT duel_id, telegram_user_id, gift_id FROM duel_stakes WHERE duel_id = $1
`

func (q *Queries) GetDuelStakes(ctx context.Context, duelID pgtype.UUID) ([]DuelStake, error) {
	rows, err := q.db.Query(ctx, getDuelStakes, duelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuelStake
	for rows.Next() {
		var i DuelStake
		if err := rows.Scan(&i.DuelID, &i.TelegramUserID, &i.GiftID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDuels = `-- name: GetDuels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, status, created_at, updated_at, completed_at FROM duels
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetDuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetDuels(ctx context.Context, arg GetDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getDuels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyDuels = `-- name: GetMyDuels :many
SELECT DISTINCT d.id, d.display_number, d.is_private, d.max_players, d.max_gifts, d.winner_telegram_user_id, d.next_roll_deadline, d.status, d.created_at, d.updated_at, d.completed_at FROM duels d
JOIN duel_participants dp ON d.id = dp.duel_id
WHERE dp.telegram_user_id = $1
ORDER BY d.created_at DESC
LIMIT $2 OFFSET $3
`

type GetMyDuelsParams struct {
	TelegramUserID int64
	Limit          int32
	Offset         int32
}

func (q *Queries) GetMyDuels(ctx context.Context, arg GetMyDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getMyDuels, arg.TelegramUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyDuelsCount = `-- name: GetMyDuelsCount :one
SELECT COUNT(DISTINCT d.id) FROM duels d
JOIN duel_participants dp ON d.id = dp.duel_id
WHERE dp.telegram_user_id = $1
`

func (q *Queries) GetMyDuelsCount(ctx context.Context, telegramUserID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getMyDuelsCount, telegramUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTopDuels = `-- name: GetTopDuels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, status, created_at, updated_at, completed_at FROM duels
WHERE status = 'completed'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetTopDuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetTopDuels(ctx context.Context, arg GetTopDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getTopDuels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopDuelsCount = `-- name: GetTopDuelsCount :one
SELECT COUNT(*) FROM duels
WHERE status = 'completed'
`

func (q *Queries) GetTopDuelsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTopDuelsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getVisibleDuels = `-- name: GetVisibleDuels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, status, created_at, updated_at, completed_at FROM duels
WHERE status IN ('waiting_for_opponent', 'in_progress')
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetVisibleDuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetVisibleDuels(ctx context.Context, arg GetVisibleDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getVisibleDuels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVisibleDuelsCount = `-- name: GetVisibleDuelsCount :one
SELECT COUNT(*) FROM duels
WHERE status IN ('waiting_for_opponent', 'in_progress')
`

func (q *Queries) GetVisibleDuelsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getVisibleDuelsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateDuelStatus = `-- name: UpdateDuelStatus :exec
UPDATE duels
  SET status = $2,
      winner_telegram_user_id = $3,
      completed_at = $4
WHERE id = $1
`

type UpdateDuelStatusParams struct {
	ID                   pgtype.UUID
	Status               NullDuelStatus
	WinnerTelegramUserID pgtype.Int8
	CompletedAt          pgtype.Timestamptz
}

func (q *Queries) UpdateDuelStatus(ctx context.Context, arg UpdateDuelStatusParams) error {
	_, err := q.db.Exec(ctx, updateDuelStatus,
		arg.ID,
		arg.Status,
		arg.WinnerTelegramUserID,
		arg.CompletedAt,
	)
	return err
}

const updateNextRollDeadline = `-- name: UpdateNextRollDeadline :exec
UPDATE duels
  SET next_roll_deadline = $2
WHERE id = $1
`

type UpdateNextRollDeadlineParams struct {
	ID               pgtype.UUID
	NextRollDeadline pgtype.Timestamptz
}

func (q *Queries) UpdateNextRollDeadline(ctx context.Context, arg UpdateNextRollDeadlineParams) error {
	_, err := q.db.Exec(ctx, updateNextRollDeadline, arg.ID, arg.NextRollDeadline)
	return err
}
