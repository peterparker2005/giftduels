// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDuel = `-- name: CreateDuel :one
INSERT INTO duels (is_private, max_players, max_gifts)
VALUES ($1, $2, $3)
RETURNING id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, total_stake_value, status, created_at, updated_at, completed_at
`

type CreateDuelParams struct {
	IsPrivate  bool
	MaxPlayers int32
	MaxGifts   int32
}

func (q *Queries) CreateDuel(ctx context.Context, arg CreateDuelParams) (Duel, error) {
	row := q.db.QueryRow(ctx, createDuel, arg.IsPrivate, arg.MaxPlayers, arg.MaxGifts)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.DisplayNumber,
		&i.IsPrivate,
		&i.MaxPlayers,
		&i.MaxGifts,
		&i.WinnerTelegramUserID,
		&i.NextRollDeadline,
		&i.TotalStakeValue,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createDuelParticipant = `-- name: CreateDuelParticipant :one
INSERT INTO duel_participants (duel_id, telegram_user_id, is_creator)
VALUES ($1, $2, $3)
RETURNING duel_id, telegram_user_id, is_creator
`

type CreateDuelParticipantParams struct {
	DuelID         pgtype.UUID
	TelegramUserID int64
	IsCreator      bool
}

func (q *Queries) CreateDuelParticipant(ctx context.Context, arg CreateDuelParticipantParams) (DuelParticipant, error) {
	row := q.db.QueryRow(ctx, createDuelParticipant, arg.DuelID, arg.TelegramUserID, arg.IsCreator)
	var i DuelParticipant
	err := row.Scan(&i.DuelID, &i.TelegramUserID, &i.IsCreator)
	return i, err
}

const createDuelRoll = `-- name: CreateDuelRoll :one
INSERT INTO duel_rolls (duel_id, round_number, telegram_user_id, dice_value, rolled_at, is_auto_rolled)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING duel_id, round_number, telegram_user_id, dice_value, rolled_at, is_auto_rolled
`

type CreateDuelRollParams struct {
	DuelID         pgtype.UUID
	RoundNumber    int32
	TelegramUserID int64
	DiceValue      int16
	RolledAt       pgtype.Timestamptz
	IsAutoRolled   bool
}

func (q *Queries) CreateDuelRoll(ctx context.Context, arg CreateDuelRollParams) (DuelRoll, error) {
	row := q.db.QueryRow(ctx, createDuelRoll,
		arg.DuelID,
		arg.RoundNumber,
		arg.TelegramUserID,
		arg.DiceValue,
		arg.RolledAt,
		arg.IsAutoRolled,
	)
	var i DuelRoll
	err := row.Scan(
		&i.DuelID,
		&i.RoundNumber,
		&i.TelegramUserID,
		&i.DiceValue,
		&i.RolledAt,
		&i.IsAutoRolled,
	)
	return i, err
}

const createDuelRound = `-- name: CreateDuelRound :one
INSERT INTO duel_rounds (duel_id, round_number)
VALUES ($1, $2)
RETURNING duel_id, round_number
`

type CreateDuelRoundParams struct {
	DuelID      pgtype.UUID
	RoundNumber int32
}

func (q *Queries) CreateDuelRound(ctx context.Context, arg CreateDuelRoundParams) (DuelRound, error) {
	row := q.db.QueryRow(ctx, createDuelRound, arg.DuelID, arg.RoundNumber)
	var i DuelRound
	err := row.Scan(&i.DuelID, &i.RoundNumber)
	return i, err
}

const createDuelStake = `-- name: CreateDuelStake :one
INSERT INTO duel_stakes (duel_id, telegram_user_id, gift_id, stake_value)
VALUES ($1, $2, $3, $4)
RETURNING duel_id, telegram_user_id, gift_id, stake_value
`

type CreateDuelStakeParams struct {
	DuelID         pgtype.UUID
	TelegramUserID int64
	GiftID         pgtype.UUID
	StakeValue     pgtype.Numeric
}

func (q *Queries) CreateDuelStake(ctx context.Context, arg CreateDuelStakeParams) (DuelStake, error) {
	row := q.db.QueryRow(ctx, createDuelStake,
		arg.DuelID,
		arg.TelegramUserID,
		arg.GiftID,
		arg.StakeValue,
	)
	var i DuelStake
	err := row.Scan(
		&i.DuelID,
		&i.TelegramUserID,
		&i.GiftID,
		&i.StakeValue,
	)
	return i, err
}

const getDuelByID = `-- name: GetDuelByID :one
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, total_stake_value, status, created_at, updated_at, completed_at FROM duels WHERE id = $1
`

func (q *Queries) GetDuelByID(ctx context.Context, id pgtype.UUID) (Duel, error) {
	row := q.db.QueryRow(ctx, getDuelByID, id)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.DisplayNumber,
		&i.IsPrivate,
		&i.MaxPlayers,
		&i.MaxGifts,
		&i.WinnerTelegramUserID,
		&i.NextRollDeadline,
		&i.TotalStakeValue,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getDuels = `-- name: GetDuels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, total_stake_value, status, created_at, updated_at, completed_at FROM duels
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetDuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetDuels(ctx context.Context, arg GetDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getDuels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.TotalStakeValue,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopDuels = `-- name: GetTopDuels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, total_stake_value, status, created_at, updated_at, completed_at FROM duels
WHERE status = 'completed'
ORDER BY created_at DESC, total_stake_value DESC
LIMIT $1 OFFSET $2
`

type GetTopDuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetTopDuels(ctx context.Context, arg GetTopDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getTopDuels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.TotalStakeValue,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVisibleDuels = `-- name: GetVisibleDuels :many
SELECT id, display_number, is_private, max_players, max_gifts, winner_telegram_user_id, next_roll_deadline, total_stake_value, status, created_at, updated_at, completed_at FROM duels
WHERE status IN ('waiting_for_opponent', 'in_progress')
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetVisibleDuelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetVisibleDuels(ctx context.Context, arg GetVisibleDuelsParams) ([]Duel, error) {
	rows, err := q.db.Query(ctx, getVisibleDuels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.DisplayNumber,
			&i.IsPrivate,
			&i.MaxPlayers,
			&i.MaxGifts,
			&i.WinnerTelegramUserID,
			&i.NextRollDeadline,
			&i.TotalStakeValue,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVisibleDuelsCount = `-- name: GetVisibleDuelsCount :one
SELECT COUNT(*) FROM duels
WHERE status IN ('waiting_for_opponent', 'in_progress')
`

func (q *Queries) GetVisibleDuelsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getVisibleDuelsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
