// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/gift/v1/gift_public_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { TonWithdrawal } from "../../payment/v1/payment";
import { GiftId, PageRequest, PageResponse, StarsAmount, SuccessResponse, TonAmount } from "../../shared/v1/common";
import { GiftView, WithdrawMethod, withdrawMethodFromJSON, withdrawMethodToJSON } from "./gift";

export interface GetGiftRequest {
  $type: "giftduels.gift.v1.GetGiftRequest";
  giftId: GiftId | undefined;
}

export interface GetGiftResponse {
  $type: "giftduels.gift.v1.GetGiftResponse";
  gift: GiftView | undefined;
}

export interface GetWithdrawOptionsRequest {
  $type: "giftduels.gift.v1.GetWithdrawOptionsRequest";
  giftId: GiftId | undefined;
}

export interface GetWithdrawOptionsResponse {
  $type: "giftduels.gift.v1.GetWithdrawOptionsResponse";
  options: WithdrawOption[];
}

export interface WithdrawOption {
  $type: "giftduels.gift.v1.WithdrawOption";
  method: WithdrawMethod;
  starsCost: StarsAmount | undefined;
  tonCost: TonAmount | undefined;
  description: string;
  isAvailable: boolean;
}

export interface WithdrawGiftRequest {
  $type: "giftduels.gift.v1.WithdrawGiftRequest";
  giftId: GiftId | undefined;
  method: WithdrawMethod;
  /** For TON withdrawals */
  walletAddress: string;
}

export interface WithdrawGiftResponse {
  $type: "giftduels.gift.v1.WithdrawGiftResponse";
  starsInvoiceUrl?: string | undefined;
  tonWithdrawal?: TonWithdrawal | undefined;
  success?:
    | SuccessResponse
    | undefined;
  /** Track withdrawal status */
  withdrawalId: string;
}

export interface GetGiftsRequest {
  $type: "giftduels.gift.v1.GetGiftsRequest";
  pagination: PageRequest | undefined;
}

export interface GetGiftsResponse {
  $type: "giftduels.gift.v1.GetGiftsResponse";
  gifts: GiftView[];
  pagination: PageResponse | undefined;
}

function createBaseGetGiftRequest(): GetGiftRequest {
  return { $type: "giftduels.gift.v1.GetGiftRequest", giftId: undefined };
}

export const GetGiftRequest: MessageFns<GetGiftRequest, "giftduels.gift.v1.GetGiftRequest"> = {
  $type: "giftduels.gift.v1.GetGiftRequest" as const,

  encode(message: GetGiftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGiftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGiftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGiftRequest {
    return { $type: GetGiftRequest.$type, giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined };
  },

  toJSON(message: GetGiftRequest): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGiftRequest>, I>>(base?: I): GetGiftRequest {
    return GetGiftRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGiftRequest>, I>>(object: I): GetGiftRequest {
    const message = createBaseGetGiftRequest();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    return message;
  },
};

function createBaseGetGiftResponse(): GetGiftResponse {
  return { $type: "giftduels.gift.v1.GetGiftResponse", gift: undefined };
}

export const GetGiftResponse: MessageFns<GetGiftResponse, "giftduels.gift.v1.GetGiftResponse"> = {
  $type: "giftduels.gift.v1.GetGiftResponse" as const,

  encode(message: GetGiftResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gift !== undefined) {
      GiftView.encode(message.gift, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGiftResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGiftResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gift = GiftView.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGiftResponse {
    return { $type: GetGiftResponse.$type, gift: isSet(object.gift) ? GiftView.fromJSON(object.gift) : undefined };
  },

  toJSON(message: GetGiftResponse): unknown {
    const obj: any = {};
    if (message.gift !== undefined) {
      obj.gift = GiftView.toJSON(message.gift);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGiftResponse>, I>>(base?: I): GetGiftResponse {
    return GetGiftResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGiftResponse>, I>>(object: I): GetGiftResponse {
    const message = createBaseGetGiftResponse();
    message.gift = (object.gift !== undefined && object.gift !== null) ? GiftView.fromPartial(object.gift) : undefined;
    return message;
  },
};

function createBaseGetWithdrawOptionsRequest(): GetWithdrawOptionsRequest {
  return { $type: "giftduels.gift.v1.GetWithdrawOptionsRequest", giftId: undefined };
}

export const GetWithdrawOptionsRequest: MessageFns<
  GetWithdrawOptionsRequest,
  "giftduels.gift.v1.GetWithdrawOptionsRequest"
> = {
  $type: "giftduels.gift.v1.GetWithdrawOptionsRequest" as const,

  encode(message: GetWithdrawOptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWithdrawOptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWithdrawOptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWithdrawOptionsRequest {
    return {
      $type: GetWithdrawOptionsRequest.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
    };
  },

  toJSON(message: GetWithdrawOptionsRequest): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWithdrawOptionsRequest>, I>>(base?: I): GetWithdrawOptionsRequest {
    return GetWithdrawOptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWithdrawOptionsRequest>, I>>(object: I): GetWithdrawOptionsRequest {
    const message = createBaseGetWithdrawOptionsRequest();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    return message;
  },
};

function createBaseGetWithdrawOptionsResponse(): GetWithdrawOptionsResponse {
  return { $type: "giftduels.gift.v1.GetWithdrawOptionsResponse", options: [] };
}

export const GetWithdrawOptionsResponse: MessageFns<
  GetWithdrawOptionsResponse,
  "giftduels.gift.v1.GetWithdrawOptionsResponse"
> = {
  $type: "giftduels.gift.v1.GetWithdrawOptionsResponse" as const,

  encode(message: GetWithdrawOptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.options) {
      WithdrawOption.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWithdrawOptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWithdrawOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.options.push(WithdrawOption.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWithdrawOptionsResponse {
    return {
      $type: GetWithdrawOptionsResponse.$type,
      options: globalThis.Array.isArray(object?.options)
        ? object.options.map((e: any) => WithdrawOption.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetWithdrawOptionsResponse): unknown {
    const obj: any = {};
    if (message.options?.length) {
      obj.options = message.options.map((e) => WithdrawOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWithdrawOptionsResponse>, I>>(base?: I): GetWithdrawOptionsResponse {
    return GetWithdrawOptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWithdrawOptionsResponse>, I>>(object: I): GetWithdrawOptionsResponse {
    const message = createBaseGetWithdrawOptionsResponse();
    message.options = object.options?.map((e) => WithdrawOption.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWithdrawOption(): WithdrawOption {
  return {
    $type: "giftduels.gift.v1.WithdrawOption",
    method: 0,
    starsCost: undefined,
    tonCost: undefined,
    description: "",
    isAvailable: false,
  };
}

export const WithdrawOption: MessageFns<WithdrawOption, "giftduels.gift.v1.WithdrawOption"> = {
  $type: "giftduels.gift.v1.WithdrawOption" as const,

  encode(message: WithdrawOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== 0) {
      writer.uint32(8).int32(message.method);
    }
    if (message.starsCost !== undefined) {
      StarsAmount.encode(message.starsCost, writer.uint32(18).fork()).join();
    }
    if (message.tonCost !== undefined) {
      TonAmount.encode(message.tonCost, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.isAvailable !== false) {
      writer.uint32(40).bool(message.isAvailable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starsCost = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tonCost = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAvailable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawOption {
    return {
      $type: WithdrawOption.$type,
      method: isSet(object.method) ? withdrawMethodFromJSON(object.method) : 0,
      starsCost: isSet(object.starsCost) ? StarsAmount.fromJSON(object.starsCost) : undefined,
      tonCost: isSet(object.tonCost) ? TonAmount.fromJSON(object.tonCost) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isAvailable: isSet(object.isAvailable) ? globalThis.Boolean(object.isAvailable) : false,
    };
  },

  toJSON(message: WithdrawOption): unknown {
    const obj: any = {};
    if (message.method !== 0) {
      obj.method = withdrawMethodToJSON(message.method);
    }
    if (message.starsCost !== undefined) {
      obj.starsCost = StarsAmount.toJSON(message.starsCost);
    }
    if (message.tonCost !== undefined) {
      obj.tonCost = TonAmount.toJSON(message.tonCost);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isAvailable !== false) {
      obj.isAvailable = message.isAvailable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawOption>, I>>(base?: I): WithdrawOption {
    return WithdrawOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawOption>, I>>(object: I): WithdrawOption {
    const message = createBaseWithdrawOption();
    message.method = object.method ?? 0;
    message.starsCost = (object.starsCost !== undefined && object.starsCost !== null)
      ? StarsAmount.fromPartial(object.starsCost)
      : undefined;
    message.tonCost = (object.tonCost !== undefined && object.tonCost !== null)
      ? TonAmount.fromPartial(object.tonCost)
      : undefined;
    message.description = object.description ?? "";
    message.isAvailable = object.isAvailable ?? false;
    return message;
  },
};

function createBaseWithdrawGiftRequest(): WithdrawGiftRequest {
  return { $type: "giftduels.gift.v1.WithdrawGiftRequest", giftId: undefined, method: 0, walletAddress: "" };
}

export const WithdrawGiftRequest: MessageFns<WithdrawGiftRequest, "giftduels.gift.v1.WithdrawGiftRequest"> = {
  $type: "giftduels.gift.v1.WithdrawGiftRequest" as const,

  encode(message: WithdrawGiftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.method !== 0) {
      writer.uint32(16).int32(message.method);
    }
    if (message.walletAddress !== "") {
      writer.uint32(26).string(message.walletAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawGiftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawGiftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.walletAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawGiftRequest {
    return {
      $type: WithdrawGiftRequest.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      method: isSet(object.method) ? withdrawMethodFromJSON(object.method) : 0,
      walletAddress: isSet(object.walletAddress) ? globalThis.String(object.walletAddress) : "",
    };
  },

  toJSON(message: WithdrawGiftRequest): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.method !== 0) {
      obj.method = withdrawMethodToJSON(message.method);
    }
    if (message.walletAddress !== "") {
      obj.walletAddress = message.walletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawGiftRequest>, I>>(base?: I): WithdrawGiftRequest {
    return WithdrawGiftRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawGiftRequest>, I>>(object: I): WithdrawGiftRequest {
    const message = createBaseWithdrawGiftRequest();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.method = object.method ?? 0;
    message.walletAddress = object.walletAddress ?? "";
    return message;
  },
};

function createBaseWithdrawGiftResponse(): WithdrawGiftResponse {
  return {
    $type: "giftduels.gift.v1.WithdrawGiftResponse",
    starsInvoiceUrl: undefined,
    tonWithdrawal: undefined,
    success: undefined,
    withdrawalId: "",
  };
}

export const WithdrawGiftResponse: MessageFns<WithdrawGiftResponse, "giftduels.gift.v1.WithdrawGiftResponse"> = {
  $type: "giftduels.gift.v1.WithdrawGiftResponse" as const,

  encode(message: WithdrawGiftResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.starsInvoiceUrl !== undefined) {
      writer.uint32(10).string(message.starsInvoiceUrl);
    }
    if (message.tonWithdrawal !== undefined) {
      TonWithdrawal.encode(message.tonWithdrawal, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined) {
      SuccessResponse.encode(message.success, writer.uint32(26).fork()).join();
    }
    if (message.withdrawalId !== "") {
      writer.uint32(34).string(message.withdrawalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawGiftResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawGiftResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starsInvoiceUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tonWithdrawal = TonWithdrawal.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.success = SuccessResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.withdrawalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawGiftResponse {
    return {
      $type: WithdrawGiftResponse.$type,
      starsInvoiceUrl: isSet(object.starsInvoiceUrl) ? globalThis.String(object.starsInvoiceUrl) : undefined,
      tonWithdrawal: isSet(object.tonWithdrawal) ? TonWithdrawal.fromJSON(object.tonWithdrawal) : undefined,
      success: isSet(object.success) ? SuccessResponse.fromJSON(object.success) : undefined,
      withdrawalId: isSet(object.withdrawalId) ? globalThis.String(object.withdrawalId) : "",
    };
  },

  toJSON(message: WithdrawGiftResponse): unknown {
    const obj: any = {};
    if (message.starsInvoiceUrl !== undefined) {
      obj.starsInvoiceUrl = message.starsInvoiceUrl;
    }
    if (message.tonWithdrawal !== undefined) {
      obj.tonWithdrawal = TonWithdrawal.toJSON(message.tonWithdrawal);
    }
    if (message.success !== undefined) {
      obj.success = SuccessResponse.toJSON(message.success);
    }
    if (message.withdrawalId !== "") {
      obj.withdrawalId = message.withdrawalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawGiftResponse>, I>>(base?: I): WithdrawGiftResponse {
    return WithdrawGiftResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawGiftResponse>, I>>(object: I): WithdrawGiftResponse {
    const message = createBaseWithdrawGiftResponse();
    message.starsInvoiceUrl = object.starsInvoiceUrl ?? undefined;
    message.tonWithdrawal = (object.tonWithdrawal !== undefined && object.tonWithdrawal !== null)
      ? TonWithdrawal.fromPartial(object.tonWithdrawal)
      : undefined;
    message.success = (object.success !== undefined && object.success !== null)
      ? SuccessResponse.fromPartial(object.success)
      : undefined;
    message.withdrawalId = object.withdrawalId ?? "";
    return message;
  },
};

function createBaseGetGiftsRequest(): GetGiftsRequest {
  return { $type: "giftduels.gift.v1.GetGiftsRequest", pagination: undefined };
}

export const GetGiftsRequest: MessageFns<GetGiftsRequest, "giftduels.gift.v1.GetGiftsRequest"> = {
  $type: "giftduels.gift.v1.GetGiftsRequest" as const,

  encode(message: GetGiftsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGiftsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGiftsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGiftsRequest {
    return {
      $type: GetGiftsRequest.$type,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetGiftsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGiftsRequest>, I>>(base?: I): GetGiftsRequest {
    return GetGiftsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGiftsRequest>, I>>(object: I): GetGiftsRequest {
    const message = createBaseGetGiftsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetGiftsResponse(): GetGiftsResponse {
  return { $type: "giftduels.gift.v1.GetGiftsResponse", gifts: [], pagination: undefined };
}

export const GetGiftsResponse: MessageFns<GetGiftsResponse, "giftduels.gift.v1.GetGiftsResponse"> = {
  $type: "giftduels.gift.v1.GetGiftsResponse" as const,

  encode(message: GetGiftsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gifts) {
      GiftView.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGiftsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGiftsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gifts.push(GiftView.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGiftsResponse {
    return {
      $type: GetGiftsResponse.$type,
      gifts: globalThis.Array.isArray(object?.gifts) ? object.gifts.map((e: any) => GiftView.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetGiftsResponse): unknown {
    const obj: any = {};
    if (message.gifts?.length) {
      obj.gifts = message.gifts.map((e) => GiftView.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGiftsResponse>, I>>(base?: I): GetGiftsResponse {
    return GetGiftsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGiftsResponse>, I>>(object: I): GetGiftsResponse {
    const message = createBaseGetGiftsResponse();
    message.gifts = object.gifts?.map((e) => GiftView.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
