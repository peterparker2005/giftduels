// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/gift/v1/gift.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import {
  GameMode,
  gameModeFromJSON,
  gameModeToJSON,
  GiftId,
  GiftTelegramId,
  TelegramUserId,
  TonAmount,
} from "../../shared/v1/common";

export enum GiftAttributeType {
  GIFT_ATTRIBUTE_TYPE_UNSPECIFIED = 0,
  GIFT_ATTRIBUTE_TYPE_MODEL = 1,
  GIFT_ATTRIBUTE_TYPE_BACKDROP = 2,
  GIFT_ATTRIBUTE_TYPE_SYMBOL = 3,
  UNRECOGNIZED = -1,
}

export function giftAttributeTypeFromJSON(object: any): GiftAttributeType {
  switch (object) {
    case 0:
    case "GIFT_ATTRIBUTE_TYPE_UNSPECIFIED":
      return GiftAttributeType.GIFT_ATTRIBUTE_TYPE_UNSPECIFIED;
    case 1:
    case "GIFT_ATTRIBUTE_TYPE_MODEL":
      return GiftAttributeType.GIFT_ATTRIBUTE_TYPE_MODEL;
    case 2:
    case "GIFT_ATTRIBUTE_TYPE_BACKDROP":
      return GiftAttributeType.GIFT_ATTRIBUTE_TYPE_BACKDROP;
    case 3:
    case "GIFT_ATTRIBUTE_TYPE_SYMBOL":
      return GiftAttributeType.GIFT_ATTRIBUTE_TYPE_SYMBOL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GiftAttributeType.UNRECOGNIZED;
  }
}

export function giftAttributeTypeToJSON(object: GiftAttributeType): string {
  switch (object) {
    case GiftAttributeType.GIFT_ATTRIBUTE_TYPE_UNSPECIFIED:
      return "GIFT_ATTRIBUTE_TYPE_UNSPECIFIED";
    case GiftAttributeType.GIFT_ATTRIBUTE_TYPE_MODEL:
      return "GIFT_ATTRIBUTE_TYPE_MODEL";
    case GiftAttributeType.GIFT_ATTRIBUTE_TYPE_BACKDROP:
      return "GIFT_ATTRIBUTE_TYPE_BACKDROP";
    case GiftAttributeType.GIFT_ATTRIBUTE_TYPE_SYMBOL:
      return "GIFT_ATTRIBUTE_TYPE_SYMBOL";
    case GiftAttributeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GiftStatus {
  GIFT_STATUS_UNSPECIFIED = 0,
  GIFT_STATUS_OWNED = 1,
  GIFT_STATUS_WITHDRAW_PENDING = 2,
  GIFT_STATUS_WITHDRAWN = 3,
  GIFT_STATUS_IN_GAME = 4,
  GIFT_STATUS_LOST = 5,
  UNRECOGNIZED = -1,
}

export function giftStatusFromJSON(object: any): GiftStatus {
  switch (object) {
    case 0:
    case "GIFT_STATUS_UNSPECIFIED":
      return GiftStatus.GIFT_STATUS_UNSPECIFIED;
    case 1:
    case "GIFT_STATUS_OWNED":
      return GiftStatus.GIFT_STATUS_OWNED;
    case 2:
    case "GIFT_STATUS_WITHDRAW_PENDING":
      return GiftStatus.GIFT_STATUS_WITHDRAW_PENDING;
    case 3:
    case "GIFT_STATUS_WITHDRAWN":
      return GiftStatus.GIFT_STATUS_WITHDRAWN;
    case 4:
    case "GIFT_STATUS_IN_GAME":
      return GiftStatus.GIFT_STATUS_IN_GAME;
    case 5:
    case "GIFT_STATUS_LOST":
      return GiftStatus.GIFT_STATUS_LOST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GiftStatus.UNRECOGNIZED;
  }
}

export function giftStatusToJSON(object: GiftStatus): string {
  switch (object) {
    case GiftStatus.GIFT_STATUS_UNSPECIFIED:
      return "GIFT_STATUS_UNSPECIFIED";
    case GiftStatus.GIFT_STATUS_OWNED:
      return "GIFT_STATUS_OWNED";
    case GiftStatus.GIFT_STATUS_WITHDRAW_PENDING:
      return "GIFT_STATUS_WITHDRAW_PENDING";
    case GiftStatus.GIFT_STATUS_WITHDRAWN:
      return "GIFT_STATUS_WITHDRAWN";
    case GiftStatus.GIFT_STATUS_IN_GAME:
      return "GIFT_STATUS_IN_GAME";
    case GiftStatus.GIFT_STATUS_LOST:
      return "GIFT_STATUS_LOST";
    case GiftStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GiftEventAction {
  GIFT_EVENT_ACTION_UNSPECIFIED = 0,
  /** GIFT_EVENT_ACTION_DEPOSIT - Deposit from Telegram to system */
  GIFT_EVENT_ACTION_DEPOSIT = 1,
  /** GIFT_EVENT_ACTION_PURCHASE - Purchase with Stars */
  GIFT_EVENT_ACTION_PURCHASE = 2,
  /** GIFT_EVENT_ACTION_WITHDRAW - Withdraw from system to Telegram */
  GIFT_EVENT_ACTION_WITHDRAW = 3,
  /** GIFT_EVENT_ACTION_GAME_WIN - Won in game */
  GIFT_EVENT_ACTION_GAME_WIN = 4,
  /** GIFT_EVENT_ACTION_GAME_LOSE - Lost in game */
  GIFT_EVENT_ACTION_GAME_LOSE = 5,
  /** GIFT_EVENT_ACTION_STAKE - Stake for game */
  GIFT_EVENT_ACTION_STAKE = 6,
  /** GIFT_EVENT_ACTION_REFUND - Refund from game */
  GIFT_EVENT_ACTION_REFUND = 7,
  UNRECOGNIZED = -1,
}

export function giftEventActionFromJSON(object: any): GiftEventAction {
  switch (object) {
    case 0:
    case "GIFT_EVENT_ACTION_UNSPECIFIED":
      return GiftEventAction.GIFT_EVENT_ACTION_UNSPECIFIED;
    case 1:
    case "GIFT_EVENT_ACTION_DEPOSIT":
      return GiftEventAction.GIFT_EVENT_ACTION_DEPOSIT;
    case 2:
    case "GIFT_EVENT_ACTION_PURCHASE":
      return GiftEventAction.GIFT_EVENT_ACTION_PURCHASE;
    case 3:
    case "GIFT_EVENT_ACTION_WITHDRAW":
      return GiftEventAction.GIFT_EVENT_ACTION_WITHDRAW;
    case 4:
    case "GIFT_EVENT_ACTION_GAME_WIN":
      return GiftEventAction.GIFT_EVENT_ACTION_GAME_WIN;
    case 5:
    case "GIFT_EVENT_ACTION_GAME_LOSE":
      return GiftEventAction.GIFT_EVENT_ACTION_GAME_LOSE;
    case 6:
    case "GIFT_EVENT_ACTION_STAKE":
      return GiftEventAction.GIFT_EVENT_ACTION_STAKE;
    case 7:
    case "GIFT_EVENT_ACTION_REFUND":
      return GiftEventAction.GIFT_EVENT_ACTION_REFUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GiftEventAction.UNRECOGNIZED;
  }
}

export function giftEventActionToJSON(object: GiftEventAction): string {
  switch (object) {
    case GiftEventAction.GIFT_EVENT_ACTION_UNSPECIFIED:
      return "GIFT_EVENT_ACTION_UNSPECIFIED";
    case GiftEventAction.GIFT_EVENT_ACTION_DEPOSIT:
      return "GIFT_EVENT_ACTION_DEPOSIT";
    case GiftEventAction.GIFT_EVENT_ACTION_PURCHASE:
      return "GIFT_EVENT_ACTION_PURCHASE";
    case GiftEventAction.GIFT_EVENT_ACTION_WITHDRAW:
      return "GIFT_EVENT_ACTION_WITHDRAW";
    case GiftEventAction.GIFT_EVENT_ACTION_GAME_WIN:
      return "GIFT_EVENT_ACTION_GAME_WIN";
    case GiftEventAction.GIFT_EVENT_ACTION_GAME_LOSE:
      return "GIFT_EVENT_ACTION_GAME_LOSE";
    case GiftEventAction.GIFT_EVENT_ACTION_STAKE:
      return "GIFT_EVENT_ACTION_STAKE";
    case GiftEventAction.GIFT_EVENT_ACTION_REFUND:
      return "GIFT_EVENT_ACTION_REFUND";
    case GiftEventAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WithdrawMethod {
  WITHDRAW_METHOD_UNSPECIFIED = 0,
  /** WITHDRAW_METHOD_STARS_PAYMENT - Pay with Stars */
  WITHDRAW_METHOD_STARS_PAYMENT = 1,
  /** WITHDRAW_METHOD_TON_PAYMENT - Pay with TON */
  WITHDRAW_METHOD_TON_PAYMENT = 2,
  UNRECOGNIZED = -1,
}

export function withdrawMethodFromJSON(object: any): WithdrawMethod {
  switch (object) {
    case 0:
    case "WITHDRAW_METHOD_UNSPECIFIED":
      return WithdrawMethod.WITHDRAW_METHOD_UNSPECIFIED;
    case 1:
    case "WITHDRAW_METHOD_STARS_PAYMENT":
      return WithdrawMethod.WITHDRAW_METHOD_STARS_PAYMENT;
    case 2:
    case "WITHDRAW_METHOD_TON_PAYMENT":
      return WithdrawMethod.WITHDRAW_METHOD_TON_PAYMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WithdrawMethod.UNRECOGNIZED;
  }
}

export function withdrawMethodToJSON(object: WithdrawMethod): string {
  switch (object) {
    case WithdrawMethod.WITHDRAW_METHOD_UNSPECIFIED:
      return "WITHDRAW_METHOD_UNSPECIFIED";
    case WithdrawMethod.WITHDRAW_METHOD_STARS_PAYMENT:
      return "WITHDRAW_METHOD_STARS_PAYMENT";
    case WithdrawMethod.WITHDRAW_METHOD_TON_PAYMENT:
      return "WITHDRAW_METHOD_TON_PAYMENT";
    case WithdrawMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Gift {
  $type: "giftduels.gift.v1.Gift";
  /** Immutable. Assigned once when the Gift enters the system. */
  giftId:
    | GiftId
    | undefined;
  /** Gift ID from Telegram gift response */
  telegramGiftId:
    | GiftTelegramId
    | undefined;
  /** Date when the gift was created in Telegram */
  date: Date | undefined;
  ownerTelegramId:
    | TelegramUserId
    | undefined;
  /** Used when gift is upgraded to a collectible */
  collectibleId: number;
  /** Used to transfer gift */
  telegramMessageId: number;
  /** Gift metadata */
  title: string;
  slug: string;
  imageUrl: string;
  /** Gift attributes */
  attributes: GiftAttribute[];
  /** Pricing information */
  originalPrice:
    | TonAmount
    | undefined;
  /** Gift status tracking */
  status: GiftStatus;
  withdrawnAt: Date | undefined;
}

export interface GiftView {
  $type: "giftduels.gift.v1.GiftView";
  giftId: GiftId | undefined;
  telegramGiftId: GiftTelegramId | undefined;
  title: string;
  slug: string;
  imageUrl: string;
  originalPrice: TonAmount | undefined;
  collectibleId: number;
  status: GiftStatus;
  withdrawnAt: Date | undefined;
}

export interface GiftAttribute {
  $type: "giftduels.gift.v1.GiftAttribute";
  type: GiftAttributeType;
  name: string;
  rarity: number;
  description: string;
}

export interface GiftEvent {
  $type: "giftduels.gift.v1.GiftEvent";
  /** Event UUID */
  eventId: string;
  giftId: GiftId | undefined;
  fromTelegramUserId: TelegramUserId | undefined;
  toTelegramUserId: TelegramUserId | undefined;
  occurredAt: Date | undefined;
  createdAt: Date | undefined;
  updatedAt:
    | Date
    | undefined;
  /** context: transfer could be related to a game */
  relatedGameId: string;
  gameMode: GameMode;
  /** Transfer metadata */
  action: GiftEventAction;
  description: string;
}

function createBaseGift(): Gift {
  return {
    $type: "giftduels.gift.v1.Gift",
    giftId: undefined,
    telegramGiftId: undefined,
    date: undefined,
    ownerTelegramId: undefined,
    collectibleId: 0,
    telegramMessageId: 0,
    title: "",
    slug: "",
    imageUrl: "",
    attributes: [],
    originalPrice: undefined,
    status: 0,
    withdrawnAt: undefined,
  };
}

export const Gift: MessageFns<Gift, "giftduels.gift.v1.Gift"> = {
  $type: "giftduels.gift.v1.Gift" as const,

  encode(message: Gift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.telegramGiftId !== undefined) {
      GiftTelegramId.encode(message.telegramGiftId, writer.uint32(18).fork()).join();
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(26).fork()).join();
    }
    if (message.ownerTelegramId !== undefined) {
      TelegramUserId.encode(message.ownerTelegramId, writer.uint32(34).fork()).join();
    }
    if (message.collectibleId !== 0) {
      writer.uint32(40).int32(message.collectibleId);
    }
    if (message.telegramMessageId !== 0) {
      writer.uint32(48).int32(message.telegramMessageId);
    }
    if (message.title !== "") {
      writer.uint32(58).string(message.title);
    }
    if (message.slug !== "") {
      writer.uint32(66).string(message.slug);
    }
    if (message.imageUrl !== "") {
      writer.uint32(74).string(message.imageUrl);
    }
    for (const v of message.attributes) {
      GiftAttribute.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.originalPrice !== undefined) {
      TonAmount.encode(message.originalPrice, writer.uint32(90).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.withdrawnAt !== undefined) {
      Timestamp.encode(toTimestamp(message.withdrawnAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegramGiftId = GiftTelegramId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerTelegramId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.collectibleId = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.telegramMessageId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attributes.push(GiftAttribute.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.originalPrice = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.withdrawnAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gift {
    return {
      $type: Gift.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      telegramGiftId: isSet(object.telegramGiftId) ? GiftTelegramId.fromJSON(object.telegramGiftId) : undefined,
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
      ownerTelegramId: isSet(object.ownerTelegramId) ? TelegramUserId.fromJSON(object.ownerTelegramId) : undefined,
      collectibleId: isSet(object.collectibleId) ? globalThis.Number(object.collectibleId) : 0,
      telegramMessageId: isSet(object.telegramMessageId) ? globalThis.Number(object.telegramMessageId) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => GiftAttribute.fromJSON(e))
        : [],
      originalPrice: isSet(object.originalPrice) ? TonAmount.fromJSON(object.originalPrice) : undefined,
      status: isSet(object.status) ? giftStatusFromJSON(object.status) : 0,
      withdrawnAt: isSet(object.withdrawnAt) ? fromJsonTimestamp(object.withdrawnAt) : undefined,
    };
  },

  toJSON(message: Gift): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.telegramGiftId !== undefined) {
      obj.telegramGiftId = GiftTelegramId.toJSON(message.telegramGiftId);
    }
    if (message.date !== undefined) {
      obj.date = message.date.toISOString();
    }
    if (message.ownerTelegramId !== undefined) {
      obj.ownerTelegramId = TelegramUserId.toJSON(message.ownerTelegramId);
    }
    if (message.collectibleId !== 0) {
      obj.collectibleId = Math.round(message.collectibleId);
    }
    if (message.telegramMessageId !== 0) {
      obj.telegramMessageId = Math.round(message.telegramMessageId);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => GiftAttribute.toJSON(e));
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = TonAmount.toJSON(message.originalPrice);
    }
    if (message.status !== 0) {
      obj.status = giftStatusToJSON(message.status);
    }
    if (message.withdrawnAt !== undefined) {
      obj.withdrawnAt = message.withdrawnAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gift>, I>>(base?: I): Gift {
    return Gift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift>, I>>(object: I): Gift {
    const message = createBaseGift();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.telegramGiftId = (object.telegramGiftId !== undefined && object.telegramGiftId !== null)
      ? GiftTelegramId.fromPartial(object.telegramGiftId)
      : undefined;
    message.date = object.date ?? undefined;
    message.ownerTelegramId = (object.ownerTelegramId !== undefined && object.ownerTelegramId !== null)
      ? TelegramUserId.fromPartial(object.ownerTelegramId)
      : undefined;
    message.collectibleId = object.collectibleId ?? 0;
    message.telegramMessageId = object.telegramMessageId ?? 0;
    message.title = object.title ?? "";
    message.slug = object.slug ?? "";
    message.imageUrl = object.imageUrl ?? "";
    message.attributes = object.attributes?.map((e) => GiftAttribute.fromPartial(e)) || [];
    message.originalPrice = (object.originalPrice !== undefined && object.originalPrice !== null)
      ? TonAmount.fromPartial(object.originalPrice)
      : undefined;
    message.status = object.status ?? 0;
    message.withdrawnAt = object.withdrawnAt ?? undefined;
    return message;
  },
};

function createBaseGiftView(): GiftView {
  return {
    $type: "giftduels.gift.v1.GiftView",
    giftId: undefined,
    telegramGiftId: undefined,
    title: "",
    slug: "",
    imageUrl: "",
    originalPrice: undefined,
    collectibleId: 0,
    status: 0,
    withdrawnAt: undefined,
  };
}

export const GiftView: MessageFns<GiftView, "giftduels.gift.v1.GiftView"> = {
  $type: "giftduels.gift.v1.GiftView" as const,

  encode(message: GiftView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.telegramGiftId !== undefined) {
      GiftTelegramId.encode(message.telegramGiftId, writer.uint32(18).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.imageUrl !== "") {
      writer.uint32(42).string(message.imageUrl);
    }
    if (message.originalPrice !== undefined) {
      TonAmount.encode(message.originalPrice, writer.uint32(50).fork()).join();
    }
    if (message.collectibleId !== 0) {
      writer.uint32(56).int32(message.collectibleId);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.withdrawnAt !== undefined) {
      Timestamp.encode(toTimestamp(message.withdrawnAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GiftView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGiftView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegramGiftId = GiftTelegramId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.originalPrice = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.collectibleId = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.withdrawnAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GiftView {
    return {
      $type: GiftView.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      telegramGiftId: isSet(object.telegramGiftId) ? GiftTelegramId.fromJSON(object.telegramGiftId) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      originalPrice: isSet(object.originalPrice) ? TonAmount.fromJSON(object.originalPrice) : undefined,
      collectibleId: isSet(object.collectibleId) ? globalThis.Number(object.collectibleId) : 0,
      status: isSet(object.status) ? giftStatusFromJSON(object.status) : 0,
      withdrawnAt: isSet(object.withdrawnAt) ? fromJsonTimestamp(object.withdrawnAt) : undefined,
    };
  },

  toJSON(message: GiftView): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.telegramGiftId !== undefined) {
      obj.telegramGiftId = GiftTelegramId.toJSON(message.telegramGiftId);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = TonAmount.toJSON(message.originalPrice);
    }
    if (message.collectibleId !== 0) {
      obj.collectibleId = Math.round(message.collectibleId);
    }
    if (message.status !== 0) {
      obj.status = giftStatusToJSON(message.status);
    }
    if (message.withdrawnAt !== undefined) {
      obj.withdrawnAt = message.withdrawnAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GiftView>, I>>(base?: I): GiftView {
    return GiftView.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GiftView>, I>>(object: I): GiftView {
    const message = createBaseGiftView();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.telegramGiftId = (object.telegramGiftId !== undefined && object.telegramGiftId !== null)
      ? GiftTelegramId.fromPartial(object.telegramGiftId)
      : undefined;
    message.title = object.title ?? "";
    message.slug = object.slug ?? "";
    message.imageUrl = object.imageUrl ?? "";
    message.originalPrice = (object.originalPrice !== undefined && object.originalPrice !== null)
      ? TonAmount.fromPartial(object.originalPrice)
      : undefined;
    message.collectibleId = object.collectibleId ?? 0;
    message.status = object.status ?? 0;
    message.withdrawnAt = object.withdrawnAt ?? undefined;
    return message;
  },
};

function createBaseGiftAttribute(): GiftAttribute {
  return { $type: "giftduels.gift.v1.GiftAttribute", type: 0, name: "", rarity: 0, description: "" };
}

export const GiftAttribute: MessageFns<GiftAttribute, "giftduels.gift.v1.GiftAttribute"> = {
  $type: "giftduels.gift.v1.GiftAttribute" as const,

  encode(message: GiftAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.rarity !== 0) {
      writer.uint32(24).int32(message.rarity);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GiftAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGiftAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rarity = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GiftAttribute {
    return {
      $type: GiftAttribute.$type,
      type: isSet(object.type) ? giftAttributeTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      rarity: isSet(object.rarity) ? globalThis.Number(object.rarity) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: GiftAttribute): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = giftAttributeTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.rarity !== 0) {
      obj.rarity = Math.round(message.rarity);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GiftAttribute>, I>>(base?: I): GiftAttribute {
    return GiftAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GiftAttribute>, I>>(object: I): GiftAttribute {
    const message = createBaseGiftAttribute();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.rarity = object.rarity ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseGiftEvent(): GiftEvent {
  return {
    $type: "giftduels.gift.v1.GiftEvent",
    eventId: "",
    giftId: undefined,
    fromTelegramUserId: undefined,
    toTelegramUserId: undefined,
    occurredAt: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    relatedGameId: "",
    gameMode: 0,
    action: 0,
    description: "",
  };
}

export const GiftEvent: MessageFns<GiftEvent, "giftduels.gift.v1.GiftEvent"> = {
  $type: "giftduels.gift.v1.GiftEvent" as const,

  encode(message: GiftEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(18).fork()).join();
    }
    if (message.fromTelegramUserId !== undefined) {
      TelegramUserId.encode(message.fromTelegramUserId, writer.uint32(26).fork()).join();
    }
    if (message.toTelegramUserId !== undefined) {
      TelegramUserId.encode(message.toTelegramUserId, writer.uint32(34).fork()).join();
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.occurredAt), writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    if (message.relatedGameId !== "") {
      writer.uint32(66).string(message.relatedGameId);
    }
    if (message.gameMode !== 0) {
      writer.uint32(72).int32(message.gameMode);
    }
    if (message.action !== 0) {
      writer.uint32(80).int32(message.action);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GiftEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGiftEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromTelegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toTelegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.occurredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.relatedGameId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GiftEvent {
    return {
      $type: GiftEvent.$type,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      fromTelegramUserId: isSet(object.fromTelegramUserId)
        ? TelegramUserId.fromJSON(object.fromTelegramUserId)
        : undefined,
      toTelegramUserId: isSet(object.toTelegramUserId) ? TelegramUserId.fromJSON(object.toTelegramUserId) : undefined,
      occurredAt: isSet(object.occurredAt) ? fromJsonTimestamp(object.occurredAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      relatedGameId: isSet(object.relatedGameId) ? globalThis.String(object.relatedGameId) : "",
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : 0,
      action: isSet(object.action) ? giftEventActionFromJSON(object.action) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: GiftEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.fromTelegramUserId !== undefined) {
      obj.fromTelegramUserId = TelegramUserId.toJSON(message.fromTelegramUserId);
    }
    if (message.toTelegramUserId !== undefined) {
      obj.toTelegramUserId = TelegramUserId.toJSON(message.toTelegramUserId);
    }
    if (message.occurredAt !== undefined) {
      obj.occurredAt = message.occurredAt.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.relatedGameId !== "") {
      obj.relatedGameId = message.relatedGameId;
    }
    if (message.gameMode !== 0) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    if (message.action !== 0) {
      obj.action = giftEventActionToJSON(message.action);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GiftEvent>, I>>(base?: I): GiftEvent {
    return GiftEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GiftEvent>, I>>(object: I): GiftEvent {
    const message = createBaseGiftEvent();
    message.eventId = object.eventId ?? "";
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.fromTelegramUserId = (object.fromTelegramUserId !== undefined && object.fromTelegramUserId !== null)
      ? TelegramUserId.fromPartial(object.fromTelegramUserId)
      : undefined;
    message.toTelegramUserId = (object.toTelegramUserId !== undefined && object.toTelegramUserId !== null)
      ? TelegramUserId.fromPartial(object.toTelegramUserId)
      : undefined;
    message.occurredAt = object.occurredAt ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.relatedGameId = object.relatedGameId ?? "";
    message.gameMode = object.gameMode ?? 0;
    message.action = object.action ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
