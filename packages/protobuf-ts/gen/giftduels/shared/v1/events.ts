// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/shared/v1/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../google/protobuf/any";
import { Timestamp } from "../../../google/protobuf/timestamp";

export enum EventPriority {
  EVENT_PRIORITY_UNSPECIFIED = 0,
  EVENT_PRIORITY_LOW = 1,
  EVENT_PRIORITY_NORMAL = 2,
  EVENT_PRIORITY_HIGH = 3,
  EVENT_PRIORITY_CRITICAL = 4,
  UNRECOGNIZED = -1,
}

export function eventPriorityFromJSON(object: any): EventPriority {
  switch (object) {
    case 0:
    case "EVENT_PRIORITY_UNSPECIFIED":
      return EventPriority.EVENT_PRIORITY_UNSPECIFIED;
    case 1:
    case "EVENT_PRIORITY_LOW":
      return EventPriority.EVENT_PRIORITY_LOW;
    case 2:
    case "EVENT_PRIORITY_NORMAL":
      return EventPriority.EVENT_PRIORITY_NORMAL;
    case 3:
    case "EVENT_PRIORITY_HIGH":
      return EventPriority.EVENT_PRIORITY_HIGH;
    case 4:
    case "EVENT_PRIORITY_CRITICAL":
      return EventPriority.EVENT_PRIORITY_CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventPriority.UNRECOGNIZED;
  }
}

export function eventPriorityToJSON(object: EventPriority): string {
  switch (object) {
    case EventPriority.EVENT_PRIORITY_UNSPECIFIED:
      return "EVENT_PRIORITY_UNSPECIFIED";
    case EventPriority.EVENT_PRIORITY_LOW:
      return "EVENT_PRIORITY_LOW";
    case EventPriority.EVENT_PRIORITY_NORMAL:
      return "EVENT_PRIORITY_NORMAL";
    case EventPriority.EVENT_PRIORITY_HIGH:
      return "EVENT_PRIORITY_HIGH";
    case EventPriority.EVENT_PRIORITY_CRITICAL:
      return "EVENT_PRIORITY_CRITICAL";
    case EventPriority.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CommonEventType {
  COMMON_EVENT_TYPE_UNSPECIFIED = 0,
  COMMON_EVENT_TYPE_ENTITY_CREATED = 1,
  COMMON_EVENT_TYPE_ENTITY_UPDATED = 2,
  COMMON_EVENT_TYPE_ENTITY_DELETED = 3,
  COMMON_EVENT_TYPE_STATE_CHANGED = 4,
  COMMON_EVENT_TYPE_WORKFLOW_STARTED = 5,
  COMMON_EVENT_TYPE_WORKFLOW_COMPLETED = 6,
  COMMON_EVENT_TYPE_WORKFLOW_FAILED = 7,
  COMMON_EVENT_TYPE_NOTIFICATION_SENT = 8,
  COMMON_EVENT_TYPE_ERROR_OCCURRED = 9,
  UNRECOGNIZED = -1,
}

export function commonEventTypeFromJSON(object: any): CommonEventType {
  switch (object) {
    case 0:
    case "COMMON_EVENT_TYPE_UNSPECIFIED":
      return CommonEventType.COMMON_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "COMMON_EVENT_TYPE_ENTITY_CREATED":
      return CommonEventType.COMMON_EVENT_TYPE_ENTITY_CREATED;
    case 2:
    case "COMMON_EVENT_TYPE_ENTITY_UPDATED":
      return CommonEventType.COMMON_EVENT_TYPE_ENTITY_UPDATED;
    case 3:
    case "COMMON_EVENT_TYPE_ENTITY_DELETED":
      return CommonEventType.COMMON_EVENT_TYPE_ENTITY_DELETED;
    case 4:
    case "COMMON_EVENT_TYPE_STATE_CHANGED":
      return CommonEventType.COMMON_EVENT_TYPE_STATE_CHANGED;
    case 5:
    case "COMMON_EVENT_TYPE_WORKFLOW_STARTED":
      return CommonEventType.COMMON_EVENT_TYPE_WORKFLOW_STARTED;
    case 6:
    case "COMMON_EVENT_TYPE_WORKFLOW_COMPLETED":
      return CommonEventType.COMMON_EVENT_TYPE_WORKFLOW_COMPLETED;
    case 7:
    case "COMMON_EVENT_TYPE_WORKFLOW_FAILED":
      return CommonEventType.COMMON_EVENT_TYPE_WORKFLOW_FAILED;
    case 8:
    case "COMMON_EVENT_TYPE_NOTIFICATION_SENT":
      return CommonEventType.COMMON_EVENT_TYPE_NOTIFICATION_SENT;
    case 9:
    case "COMMON_EVENT_TYPE_ERROR_OCCURRED":
      return CommonEventType.COMMON_EVENT_TYPE_ERROR_OCCURRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommonEventType.UNRECOGNIZED;
  }
}

export function commonEventTypeToJSON(object: CommonEventType): string {
  switch (object) {
    case CommonEventType.COMMON_EVENT_TYPE_UNSPECIFIED:
      return "COMMON_EVENT_TYPE_UNSPECIFIED";
    case CommonEventType.COMMON_EVENT_TYPE_ENTITY_CREATED:
      return "COMMON_EVENT_TYPE_ENTITY_CREATED";
    case CommonEventType.COMMON_EVENT_TYPE_ENTITY_UPDATED:
      return "COMMON_EVENT_TYPE_ENTITY_UPDATED";
    case CommonEventType.COMMON_EVENT_TYPE_ENTITY_DELETED:
      return "COMMON_EVENT_TYPE_ENTITY_DELETED";
    case CommonEventType.COMMON_EVENT_TYPE_STATE_CHANGED:
      return "COMMON_EVENT_TYPE_STATE_CHANGED";
    case CommonEventType.COMMON_EVENT_TYPE_WORKFLOW_STARTED:
      return "COMMON_EVENT_TYPE_WORKFLOW_STARTED";
    case CommonEventType.COMMON_EVENT_TYPE_WORKFLOW_COMPLETED:
      return "COMMON_EVENT_TYPE_WORKFLOW_COMPLETED";
    case CommonEventType.COMMON_EVENT_TYPE_WORKFLOW_FAILED:
      return "COMMON_EVENT_TYPE_WORKFLOW_FAILED";
    case CommonEventType.COMMON_EVENT_TYPE_NOTIFICATION_SENT:
      return "COMMON_EVENT_TYPE_NOTIFICATION_SENT";
    case CommonEventType.COMMON_EVENT_TYPE_ERROR_OCCURRED:
      return "COMMON_EVENT_TYPE_ERROR_OCCURRED";
    case CommonEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChangeType {
  CHANGE_TYPE_UNSPECIFIED = 0,
  CHANGE_TYPE_CREATED = 1,
  CHANGE_TYPE_UPDATED = 2,
  CHANGE_TYPE_DELETED = 3,
  CHANGE_TYPE_ARCHIVED = 4,
  CHANGE_TYPE_RESTORED = 5,
  UNRECOGNIZED = -1,
}

export function changeTypeFromJSON(object: any): ChangeType {
  switch (object) {
    case 0:
    case "CHANGE_TYPE_UNSPECIFIED":
      return ChangeType.CHANGE_TYPE_UNSPECIFIED;
    case 1:
    case "CHANGE_TYPE_CREATED":
      return ChangeType.CHANGE_TYPE_CREATED;
    case 2:
    case "CHANGE_TYPE_UPDATED":
      return ChangeType.CHANGE_TYPE_UPDATED;
    case 3:
    case "CHANGE_TYPE_DELETED":
      return ChangeType.CHANGE_TYPE_DELETED;
    case 4:
    case "CHANGE_TYPE_ARCHIVED":
      return ChangeType.CHANGE_TYPE_ARCHIVED;
    case 5:
    case "CHANGE_TYPE_RESTORED":
      return ChangeType.CHANGE_TYPE_RESTORED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeType.UNRECOGNIZED;
  }
}

export function changeTypeToJSON(object: ChangeType): string {
  switch (object) {
    case ChangeType.CHANGE_TYPE_UNSPECIFIED:
      return "CHANGE_TYPE_UNSPECIFIED";
    case ChangeType.CHANGE_TYPE_CREATED:
      return "CHANGE_TYPE_CREATED";
    case ChangeType.CHANGE_TYPE_UPDATED:
      return "CHANGE_TYPE_UPDATED";
    case ChangeType.CHANGE_TYPE_DELETED:
      return "CHANGE_TYPE_DELETED";
    case ChangeType.CHANGE_TYPE_ARCHIVED:
      return "CHANGE_TYPE_ARCHIVED";
    case ChangeType.CHANGE_TYPE_RESTORED:
      return "CHANGE_TYPE_RESTORED";
    case ChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkflowStatus {
  WORKFLOW_STATUS_UNSPECIFIED = 0,
  WORKFLOW_STATUS_STARTED = 1,
  WORKFLOW_STATUS_IN_PROGRESS = 2,
  WORKFLOW_STATUS_PAUSED = 3,
  WORKFLOW_STATUS_COMPLETED = 4,
  WORKFLOW_STATUS_FAILED = 5,
  WORKFLOW_STATUS_CANCELLED = 6,
  UNRECOGNIZED = -1,
}

export function workflowStatusFromJSON(object: any): WorkflowStatus {
  switch (object) {
    case 0:
    case "WORKFLOW_STATUS_UNSPECIFIED":
      return WorkflowStatus.WORKFLOW_STATUS_UNSPECIFIED;
    case 1:
    case "WORKFLOW_STATUS_STARTED":
      return WorkflowStatus.WORKFLOW_STATUS_STARTED;
    case 2:
    case "WORKFLOW_STATUS_IN_PROGRESS":
      return WorkflowStatus.WORKFLOW_STATUS_IN_PROGRESS;
    case 3:
    case "WORKFLOW_STATUS_PAUSED":
      return WorkflowStatus.WORKFLOW_STATUS_PAUSED;
    case 4:
    case "WORKFLOW_STATUS_COMPLETED":
      return WorkflowStatus.WORKFLOW_STATUS_COMPLETED;
    case 5:
    case "WORKFLOW_STATUS_FAILED":
      return WorkflowStatus.WORKFLOW_STATUS_FAILED;
    case 6:
    case "WORKFLOW_STATUS_CANCELLED":
      return WorkflowStatus.WORKFLOW_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowStatus.UNRECOGNIZED;
  }
}

export function workflowStatusToJSON(object: WorkflowStatus): string {
  switch (object) {
    case WorkflowStatus.WORKFLOW_STATUS_UNSPECIFIED:
      return "WORKFLOW_STATUS_UNSPECIFIED";
    case WorkflowStatus.WORKFLOW_STATUS_STARTED:
      return "WORKFLOW_STATUS_STARTED";
    case WorkflowStatus.WORKFLOW_STATUS_IN_PROGRESS:
      return "WORKFLOW_STATUS_IN_PROGRESS";
    case WorkflowStatus.WORKFLOW_STATUS_PAUSED:
      return "WORKFLOW_STATUS_PAUSED";
    case WorkflowStatus.WORKFLOW_STATUS_COMPLETED:
      return "WORKFLOW_STATUS_COMPLETED";
    case WorkflowStatus.WORKFLOW_STATUS_FAILED:
      return "WORKFLOW_STATUS_FAILED";
    case WorkflowStatus.WORKFLOW_STATUS_CANCELLED:
      return "WORKFLOW_STATUS_CANCELLED";
    case WorkflowStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NotificationType {
  NOTIFICATION_TYPE_UNSPECIFIED = 0,
  NOTIFICATION_TYPE_INFO = 1,
  NOTIFICATION_TYPE_SUCCESS = 2,
  NOTIFICATION_TYPE_WARNING = 3,
  NOTIFICATION_TYPE_ERROR = 4,
  NOTIFICATION_TYPE_GAME_UPDATE = 5,
  NOTIFICATION_TYPE_TRANSACTION = 6,
  UNRECOGNIZED = -1,
}

export function notificationTypeFromJSON(object: any): NotificationType {
  switch (object) {
    case 0:
    case "NOTIFICATION_TYPE_UNSPECIFIED":
      return NotificationType.NOTIFICATION_TYPE_UNSPECIFIED;
    case 1:
    case "NOTIFICATION_TYPE_INFO":
      return NotificationType.NOTIFICATION_TYPE_INFO;
    case 2:
    case "NOTIFICATION_TYPE_SUCCESS":
      return NotificationType.NOTIFICATION_TYPE_SUCCESS;
    case 3:
    case "NOTIFICATION_TYPE_WARNING":
      return NotificationType.NOTIFICATION_TYPE_WARNING;
    case 4:
    case "NOTIFICATION_TYPE_ERROR":
      return NotificationType.NOTIFICATION_TYPE_ERROR;
    case 5:
    case "NOTIFICATION_TYPE_GAME_UPDATE":
      return NotificationType.NOTIFICATION_TYPE_GAME_UPDATE;
    case 6:
    case "NOTIFICATION_TYPE_TRANSACTION":
      return NotificationType.NOTIFICATION_TYPE_TRANSACTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationType.UNRECOGNIZED;
  }
}

export function notificationTypeToJSON(object: NotificationType): string {
  switch (object) {
    case NotificationType.NOTIFICATION_TYPE_UNSPECIFIED:
      return "NOTIFICATION_TYPE_UNSPECIFIED";
    case NotificationType.NOTIFICATION_TYPE_INFO:
      return "NOTIFICATION_TYPE_INFO";
    case NotificationType.NOTIFICATION_TYPE_SUCCESS:
      return "NOTIFICATION_TYPE_SUCCESS";
    case NotificationType.NOTIFICATION_TYPE_WARNING:
      return "NOTIFICATION_TYPE_WARNING";
    case NotificationType.NOTIFICATION_TYPE_ERROR:
      return "NOTIFICATION_TYPE_ERROR";
    case NotificationType.NOTIFICATION_TYPE_GAME_UPDATE:
      return "NOTIFICATION_TYPE_GAME_UPDATE";
    case NotificationType.NOTIFICATION_TYPE_TRANSACTION:
      return "NOTIFICATION_TYPE_TRANSACTION";
    case NotificationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NotificationChannel {
  NOTIFICATION_CHANNEL_UNSPECIFIED = 0,
  NOTIFICATION_CHANNEL_TELEGRAM_BOT = 1,
  NOTIFICATION_CHANNEL_IN_APP = 2,
  NOTIFICATION_CHANNEL_PUSH = 3,
  NOTIFICATION_CHANNEL_EMAIL = 4,
  UNRECOGNIZED = -1,
}

export function notificationChannelFromJSON(object: any): NotificationChannel {
  switch (object) {
    case 0:
    case "NOTIFICATION_CHANNEL_UNSPECIFIED":
      return NotificationChannel.NOTIFICATION_CHANNEL_UNSPECIFIED;
    case 1:
    case "NOTIFICATION_CHANNEL_TELEGRAM_BOT":
      return NotificationChannel.NOTIFICATION_CHANNEL_TELEGRAM_BOT;
    case 2:
    case "NOTIFICATION_CHANNEL_IN_APP":
      return NotificationChannel.NOTIFICATION_CHANNEL_IN_APP;
    case 3:
    case "NOTIFICATION_CHANNEL_PUSH":
      return NotificationChannel.NOTIFICATION_CHANNEL_PUSH;
    case 4:
    case "NOTIFICATION_CHANNEL_EMAIL":
      return NotificationChannel.NOTIFICATION_CHANNEL_EMAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationChannel.UNRECOGNIZED;
  }
}

export function notificationChannelToJSON(object: NotificationChannel): string {
  switch (object) {
    case NotificationChannel.NOTIFICATION_CHANNEL_UNSPECIFIED:
      return "NOTIFICATION_CHANNEL_UNSPECIFIED";
    case NotificationChannel.NOTIFICATION_CHANNEL_TELEGRAM_BOT:
      return "NOTIFICATION_CHANNEL_TELEGRAM_BOT";
    case NotificationChannel.NOTIFICATION_CHANNEL_IN_APP:
      return "NOTIFICATION_CHANNEL_IN_APP";
    case NotificationChannel.NOTIFICATION_CHANNEL_PUSH:
      return "NOTIFICATION_CHANNEL_PUSH";
    case NotificationChannel.NOTIFICATION_CHANNEL_EMAIL:
      return "NOTIFICATION_CHANNEL_EMAIL";
    case NotificationChannel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Event {
  $type: "giftduels.shared.v1.Event";
  /** Unique event identifier */
  eventId: string;
  /** Event type identifier */
  eventType: string;
  /** Service that generated the event */
  sourceService: string;
  timestamp:
    | Date
    | undefined;
  /** Event-specific data */
  payload: Any | undefined;
  metadata: EventMetadata | undefined;
}

export interface EventMetadata {
  $type: "giftduels.shared.v1.EventMetadata";
  /** For tracking related events */
  correlationId: string;
  /** ID of the event that caused this event */
  causationId: string;
  /** User who triggered the event */
  userId: string;
  /** Telegram user ID */
  telegramUserId: string;
  /** Custom labels for filtering/routing */
  labels: { [key: string]: string };
  priority: EventPriority;
}

export interface EventMetadata_LabelsEntry {
  $type: "giftduels.shared.v1.EventMetadata.LabelsEntry";
  key: string;
  value: string;
}

export interface EventEnvelope {
  $type: "giftduels.shared.v1.EventEnvelope";
  event: Event | undefined;
  delivery: DeliveryMetadata | undefined;
}

export interface DeliveryMetadata {
  $type: "giftduels.shared.v1.DeliveryMetadata";
  sentAt: Date | undefined;
  deliveredAt: Date | undefined;
  retryCount: number;
  routingKey: string;
  headers: { [key: string]: string };
}

export interface DeliveryMetadata_HeadersEntry {
  $type: "giftduels.shared.v1.DeliveryMetadata.HeadersEntry";
  key: string;
  value: string;
}

export interface EventSubscription {
  $type: "giftduels.shared.v1.EventSubscription";
  subscriptionId: string;
  subscriberService: string;
  /** Event types to subscribe to */
  eventTypes: string[];
  filter: EventFilter | undefined;
  config: SubscriptionConfig | undefined;
}

export interface EventFilter {
  $type: "giftduels.shared.v1.EventFilter";
  /** Filter by source service */
  sourceServices: string[];
  /** Filter by labels */
  labelSelectors: { [key: string]: string };
  minPriority: EventPriority;
  userIdFilter: string;
}

export interface EventFilter_LabelSelectorsEntry {
  $type: "giftduels.shared.v1.EventFilter.LabelSelectorsEntry";
  key: string;
  value: string;
}

export interface SubscriptionConfig {
  $type: "giftduels.shared.v1.SubscriptionConfig";
  enableRetry: boolean;
  maxRetries: number;
  retryDelaySeconds: number;
  enableDeadLetter: boolean;
  /** Ignore events older than this */
  maxAgeHours: number;
}

export interface EntityChangeEvent {
  $type: "giftduels.shared.v1.EntityChangeEvent";
  /** e.g., "user", "gift", "duel" */
  entityType: string;
  entityId: string;
  changeType: ChangeType;
  /** State before change (for updates) */
  beforeState:
    | Any
    | undefined;
  /** State after change */
  afterState:
    | Any
    | undefined;
  /** For updates only */
  changedFields: string[];
}

export interface WorkflowEvent {
  $type: "giftduels.shared.v1.WorkflowEvent";
  workflowId: string;
  /** e.g., "gift_withdrawal", "duel_completion" */
  workflowType: string;
  status: WorkflowStatus;
  /** Current workflow step */
  stepName: string;
  /** Workflow-specific context */
  context:
    | Any
    | undefined;
  /** If status is FAILED */
  errorMessage: string;
}

export interface NotificationEvent {
  $type: "giftduels.shared.v1.NotificationEvent";
  notificationId: string;
  type: NotificationType;
  recipientTelegramId: string;
  title: string;
  message: string;
  /** Additional data for rich notifications */
  data: Any | undefined;
  channel: NotificationChannel;
}

function createBaseEvent(): Event {
  return {
    $type: "giftduels.shared.v1.Event",
    eventId: "",
    eventType: "",
    sourceService: "",
    timestamp: undefined,
    payload: undefined,
    metadata: undefined,
  };
}

export const Event: MessageFns<Event, "giftduels.shared.v1.Event"> = {
  $type: "giftduels.shared.v1.Event" as const,

  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.sourceService !== "") {
      writer.uint32(26).string(message.sourceService);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    if (message.payload !== undefined) {
      Any.encode(message.payload, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      EventMetadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceService = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = Any.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = EventMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      $type: Event.$type,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sourceService: isSet(object.sourceService) ? globalThis.String(object.sourceService) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      payload: isSet(object.payload) ? Any.fromJSON(object.payload) : undefined,
      metadata: isSet(object.metadata) ? EventMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sourceService !== "") {
      obj.sourceService = message.sourceService;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.payload !== undefined) {
      obj.payload = Any.toJSON(message.payload);
    }
    if (message.metadata !== undefined) {
      obj.metadata = EventMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.eventId = object.eventId ?? "";
    message.eventType = object.eventType ?? "";
    message.sourceService = object.sourceService ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Any.fromPartial(object.payload)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? EventMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseEventMetadata(): EventMetadata {
  return {
    $type: "giftduels.shared.v1.EventMetadata",
    correlationId: "",
    causationId: "",
    userId: "",
    telegramUserId: "0",
    labels: {},
    priority: 0,
  };
}

export const EventMetadata: MessageFns<EventMetadata, "giftduels.shared.v1.EventMetadata"> = {
  $type: "giftduels.shared.v1.EventMetadata" as const,

  encode(message: EventMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.correlationId !== "") {
      writer.uint32(10).string(message.correlationId);
    }
    if (message.causationId !== "") {
      writer.uint32(18).string(message.causationId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.telegramUserId !== "0") {
      writer.uint32(32).int64(message.telegramUserId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      EventMetadata_LabelsEntry.encode({
        $type: "giftduels.shared.v1.EventMetadata.LabelsEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.causationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.telegramUserId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = EventMetadata_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMetadata {
    return {
      $type: EventMetadata.$type,
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      causationId: isSet(object.causationId) ? globalThis.String(object.causationId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      telegramUserId: isSet(object.telegramUserId) ? globalThis.String(object.telegramUserId) : "0",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      priority: isSet(object.priority) ? eventPriorityFromJSON(object.priority) : 0,
    };
  },

  toJSON(message: EventMetadata): unknown {
    const obj: any = {};
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.causationId !== "") {
      obj.causationId = message.causationId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.telegramUserId !== "0") {
      obj.telegramUserId = message.telegramUserId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.priority !== 0) {
      obj.priority = eventPriorityToJSON(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMetadata>, I>>(base?: I): EventMetadata {
    return EventMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMetadata>, I>>(object: I): EventMetadata {
    const message = createBaseEventMetadata();
    message.correlationId = object.correlationId ?? "";
    message.causationId = object.causationId ?? "";
    message.userId = object.userId ?? "";
    message.telegramUserId = object.telegramUserId ?? "0";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseEventMetadata_LabelsEntry(): EventMetadata_LabelsEntry {
  return { $type: "giftduels.shared.v1.EventMetadata.LabelsEntry", key: "", value: "" };
}

export const EventMetadata_LabelsEntry: MessageFns<
  EventMetadata_LabelsEntry,
  "giftduels.shared.v1.EventMetadata.LabelsEntry"
> = {
  $type: "giftduels.shared.v1.EventMetadata.LabelsEntry" as const,

  encode(message: EventMetadata_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMetadata_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMetadata_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMetadata_LabelsEntry {
    return {
      $type: EventMetadata_LabelsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EventMetadata_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMetadata_LabelsEntry>, I>>(base?: I): EventMetadata_LabelsEntry {
    return EventMetadata_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMetadata_LabelsEntry>, I>>(object: I): EventMetadata_LabelsEntry {
    const message = createBaseEventMetadata_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEventEnvelope(): EventEnvelope {
  return { $type: "giftduels.shared.v1.EventEnvelope", event: undefined, delivery: undefined };
}

export const EventEnvelope: MessageFns<EventEnvelope, "giftduels.shared.v1.EventEnvelope"> = {
  $type: "giftduels.shared.v1.EventEnvelope" as const,

  encode(message: EventEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.delivery !== undefined) {
      DeliveryMetadata.encode(message.delivery, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delivery = DeliveryMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnvelope {
    return {
      $type: EventEnvelope.$type,
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      delivery: isSet(object.delivery) ? DeliveryMetadata.fromJSON(object.delivery) : undefined,
    };
  },

  toJSON(message: EventEnvelope): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.delivery !== undefined) {
      obj.delivery = DeliveryMetadata.toJSON(message.delivery);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventEnvelope>, I>>(base?: I): EventEnvelope {
    return EventEnvelope.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventEnvelope>, I>>(object: I): EventEnvelope {
    const message = createBaseEventEnvelope();
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.delivery = (object.delivery !== undefined && object.delivery !== null)
      ? DeliveryMetadata.fromPartial(object.delivery)
      : undefined;
    return message;
  },
};

function createBaseDeliveryMetadata(): DeliveryMetadata {
  return {
    $type: "giftduels.shared.v1.DeliveryMetadata",
    sentAt: undefined,
    deliveredAt: undefined,
    retryCount: 0,
    routingKey: "",
    headers: {},
  };
}

export const DeliveryMetadata: MessageFns<DeliveryMetadata, "giftduels.shared.v1.DeliveryMetadata"> = {
  $type: "giftduels.shared.v1.DeliveryMetadata" as const,

  encode(message: DeliveryMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sentAt !== undefined) {
      Timestamp.encode(toTimestamp(message.sentAt), writer.uint32(10).fork()).join();
    }
    if (message.deliveredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deliveredAt), writer.uint32(18).fork()).join();
    }
    if (message.retryCount !== 0) {
      writer.uint32(24).int32(message.retryCount);
    }
    if (message.routingKey !== "") {
      writer.uint32(34).string(message.routingKey);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      DeliveryMetadata_HeadersEntry.encode({
        $type: "giftduels.shared.v1.DeliveryMetadata.HeadersEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sentAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.routingKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = DeliveryMetadata_HeadersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.headers[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryMetadata {
    return {
      $type: DeliveryMetadata.$type,
      sentAt: isSet(object.sentAt) ? fromJsonTimestamp(object.sentAt) : undefined,
      deliveredAt: isSet(object.deliveredAt) ? fromJsonTimestamp(object.deliveredAt) : undefined,
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      routingKey: isSet(object.routingKey) ? globalThis.String(object.routingKey) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DeliveryMetadata): unknown {
    const obj: any = {};
    if (message.sentAt !== undefined) {
      obj.sentAt = message.sentAt.toISOString();
    }
    if (message.deliveredAt !== undefined) {
      obj.deliveredAt = message.deliveredAt.toISOString();
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.routingKey !== "") {
      obj.routingKey = message.routingKey;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeliveryMetadata>, I>>(base?: I): DeliveryMetadata {
    return DeliveryMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeliveryMetadata>, I>>(object: I): DeliveryMetadata {
    const message = createBaseDeliveryMetadata();
    message.sentAt = object.sentAt ?? undefined;
    message.deliveredAt = object.deliveredAt ?? undefined;
    message.retryCount = object.retryCount ?? 0;
    message.routingKey = object.routingKey ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDeliveryMetadata_HeadersEntry(): DeliveryMetadata_HeadersEntry {
  return { $type: "giftduels.shared.v1.DeliveryMetadata.HeadersEntry", key: "", value: "" };
}

export const DeliveryMetadata_HeadersEntry: MessageFns<
  DeliveryMetadata_HeadersEntry,
  "giftduels.shared.v1.DeliveryMetadata.HeadersEntry"
> = {
  $type: "giftduels.shared.v1.DeliveryMetadata.HeadersEntry" as const,

  encode(message: DeliveryMetadata_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryMetadata_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryMetadata_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryMetadata_HeadersEntry {
    return {
      $type: DeliveryMetadata_HeadersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeliveryMetadata_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeliveryMetadata_HeadersEntry>, I>>(base?: I): DeliveryMetadata_HeadersEntry {
    return DeliveryMetadata_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeliveryMetadata_HeadersEntry>, I>>(
    object: I,
  ): DeliveryMetadata_HeadersEntry {
    const message = createBaseDeliveryMetadata_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEventSubscription(): EventSubscription {
  return {
    $type: "giftduels.shared.v1.EventSubscription",
    subscriptionId: "",
    subscriberService: "",
    eventTypes: [],
    filter: undefined,
    config: undefined,
  };
}

export const EventSubscription: MessageFns<EventSubscription, "giftduels.shared.v1.EventSubscription"> = {
  $type: "giftduels.shared.v1.EventSubscription" as const,

  encode(message: EventSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.subscriberService !== "") {
      writer.uint32(18).string(message.subscriberService);
    }
    for (const v of message.eventTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.filter !== undefined) {
      EventFilter.encode(message.filter, writer.uint32(34).fork()).join();
    }
    if (message.config !== undefined) {
      SubscriptionConfig.encode(message.config, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriberService = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventTypes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = EventFilter.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config = SubscriptionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubscription {
    return {
      $type: EventSubscription.$type,
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      subscriberService: isSet(object.subscriberService) ? globalThis.String(object.subscriberService) : "",
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => globalThis.String(e))
        : [],
      filter: isSet(object.filter) ? EventFilter.fromJSON(object.filter) : undefined,
      config: isSet(object.config) ? SubscriptionConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: EventSubscription): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.subscriberService !== "") {
      obj.subscriberService = message.subscriberService;
    }
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes;
    }
    if (message.filter !== undefined) {
      obj.filter = EventFilter.toJSON(message.filter);
    }
    if (message.config !== undefined) {
      obj.config = SubscriptionConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventSubscription>, I>>(base?: I): EventSubscription {
    return EventSubscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventSubscription>, I>>(object: I): EventSubscription {
    const message = createBaseEventSubscription();
    message.subscriptionId = object.subscriptionId ?? "";
    message.subscriberService = object.subscriberService ?? "";
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? EventFilter.fromPartial(object.filter)
      : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? SubscriptionConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseEventFilter(): EventFilter {
  return {
    $type: "giftduels.shared.v1.EventFilter",
    sourceServices: [],
    labelSelectors: {},
    minPriority: 0,
    userIdFilter: "",
  };
}

export const EventFilter: MessageFns<EventFilter, "giftduels.shared.v1.EventFilter"> = {
  $type: "giftduels.shared.v1.EventFilter" as const,

  encode(message: EventFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sourceServices) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.labelSelectors).forEach(([key, value]) => {
      EventFilter_LabelSelectorsEntry.encode({
        $type: "giftduels.shared.v1.EventFilter.LabelSelectorsEntry",
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    if (message.minPriority !== 0) {
      writer.uint32(24).int32(message.minPriority);
    }
    if (message.userIdFilter !== "") {
      writer.uint32(34).string(message.userIdFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceServices.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = EventFilter_LabelSelectorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labelSelectors[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minPriority = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdFilter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFilter {
    return {
      $type: EventFilter.$type,
      sourceServices: globalThis.Array.isArray(object?.sourceServices)
        ? object.sourceServices.map((e: any) => globalThis.String(e))
        : [],
      labelSelectors: isObject(object.labelSelectors)
        ? Object.entries(object.labelSelectors).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      minPriority: isSet(object.minPriority) ? eventPriorityFromJSON(object.minPriority) : 0,
      userIdFilter: isSet(object.userIdFilter) ? globalThis.String(object.userIdFilter) : "",
    };
  },

  toJSON(message: EventFilter): unknown {
    const obj: any = {};
    if (message.sourceServices?.length) {
      obj.sourceServices = message.sourceServices;
    }
    if (message.labelSelectors) {
      const entries = Object.entries(message.labelSelectors);
      if (entries.length > 0) {
        obj.labelSelectors = {};
        entries.forEach(([k, v]) => {
          obj.labelSelectors[k] = v;
        });
      }
    }
    if (message.minPriority !== 0) {
      obj.minPriority = eventPriorityToJSON(message.minPriority);
    }
    if (message.userIdFilter !== "") {
      obj.userIdFilter = message.userIdFilter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFilter>, I>>(base?: I): EventFilter {
    return EventFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFilter>, I>>(object: I): EventFilter {
    const message = createBaseEventFilter();
    message.sourceServices = object.sourceServices?.map((e) => e) || [];
    message.labelSelectors = Object.entries(object.labelSelectors ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.minPriority = object.minPriority ?? 0;
    message.userIdFilter = object.userIdFilter ?? "";
    return message;
  },
};

function createBaseEventFilter_LabelSelectorsEntry(): EventFilter_LabelSelectorsEntry {
  return { $type: "giftduels.shared.v1.EventFilter.LabelSelectorsEntry", key: "", value: "" };
}

export const EventFilter_LabelSelectorsEntry: MessageFns<
  EventFilter_LabelSelectorsEntry,
  "giftduels.shared.v1.EventFilter.LabelSelectorsEntry"
> = {
  $type: "giftduels.shared.v1.EventFilter.LabelSelectorsEntry" as const,

  encode(message: EventFilter_LabelSelectorsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFilter_LabelSelectorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFilter_LabelSelectorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFilter_LabelSelectorsEntry {
    return {
      $type: EventFilter_LabelSelectorsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EventFilter_LabelSelectorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFilter_LabelSelectorsEntry>, I>>(base?: I): EventFilter_LabelSelectorsEntry {
    return EventFilter_LabelSelectorsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFilter_LabelSelectorsEntry>, I>>(
    object: I,
  ): EventFilter_LabelSelectorsEntry {
    const message = createBaseEventFilter_LabelSelectorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSubscriptionConfig(): SubscriptionConfig {
  return {
    $type: "giftduels.shared.v1.SubscriptionConfig",
    enableRetry: false,
    maxRetries: 0,
    retryDelaySeconds: 0,
    enableDeadLetter: false,
    maxAgeHours: 0,
  };
}

export const SubscriptionConfig: MessageFns<SubscriptionConfig, "giftduels.shared.v1.SubscriptionConfig"> = {
  $type: "giftduels.shared.v1.SubscriptionConfig" as const,

  encode(message: SubscriptionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableRetry !== false) {
      writer.uint32(8).bool(message.enableRetry);
    }
    if (message.maxRetries !== 0) {
      writer.uint32(16).int32(message.maxRetries);
    }
    if (message.retryDelaySeconds !== 0) {
      writer.uint32(24).int32(message.retryDelaySeconds);
    }
    if (message.enableDeadLetter !== false) {
      writer.uint32(32).bool(message.enableDeadLetter);
    }
    if (message.maxAgeHours !== 0) {
      writer.uint32(40).int32(message.maxAgeHours);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enableRetry = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxRetries = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.retryDelaySeconds = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enableDeadLetter = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxAgeHours = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionConfig {
    return {
      $type: SubscriptionConfig.$type,
      enableRetry: isSet(object.enableRetry) ? globalThis.Boolean(object.enableRetry) : false,
      maxRetries: isSet(object.maxRetries) ? globalThis.Number(object.maxRetries) : 0,
      retryDelaySeconds: isSet(object.retryDelaySeconds) ? globalThis.Number(object.retryDelaySeconds) : 0,
      enableDeadLetter: isSet(object.enableDeadLetter) ? globalThis.Boolean(object.enableDeadLetter) : false,
      maxAgeHours: isSet(object.maxAgeHours) ? globalThis.Number(object.maxAgeHours) : 0,
    };
  },

  toJSON(message: SubscriptionConfig): unknown {
    const obj: any = {};
    if (message.enableRetry !== false) {
      obj.enableRetry = message.enableRetry;
    }
    if (message.maxRetries !== 0) {
      obj.maxRetries = Math.round(message.maxRetries);
    }
    if (message.retryDelaySeconds !== 0) {
      obj.retryDelaySeconds = Math.round(message.retryDelaySeconds);
    }
    if (message.enableDeadLetter !== false) {
      obj.enableDeadLetter = message.enableDeadLetter;
    }
    if (message.maxAgeHours !== 0) {
      obj.maxAgeHours = Math.round(message.maxAgeHours);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionConfig>, I>>(base?: I): SubscriptionConfig {
    return SubscriptionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionConfig>, I>>(object: I): SubscriptionConfig {
    const message = createBaseSubscriptionConfig();
    message.enableRetry = object.enableRetry ?? false;
    message.maxRetries = object.maxRetries ?? 0;
    message.retryDelaySeconds = object.retryDelaySeconds ?? 0;
    message.enableDeadLetter = object.enableDeadLetter ?? false;
    message.maxAgeHours = object.maxAgeHours ?? 0;
    return message;
  },
};

function createBaseEntityChangeEvent(): EntityChangeEvent {
  return {
    $type: "giftduels.shared.v1.EntityChangeEvent",
    entityType: "",
    entityId: "",
    changeType: 0,
    beforeState: undefined,
    afterState: undefined,
    changedFields: [],
  };
}

export const EntityChangeEvent: MessageFns<EntityChangeEvent, "giftduels.shared.v1.EntityChangeEvent"> = {
  $type: "giftduels.shared.v1.EntityChangeEvent" as const,

  encode(message: EntityChangeEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityType !== "") {
      writer.uint32(10).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(18).string(message.entityId);
    }
    if (message.changeType !== 0) {
      writer.uint32(24).int32(message.changeType);
    }
    if (message.beforeState !== undefined) {
      Any.encode(message.beforeState, writer.uint32(34).fork()).join();
    }
    if (message.afterState !== undefined) {
      Any.encode(message.afterState, writer.uint32(42).fork()).join();
    }
    for (const v of message.changedFields) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityChangeEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityChangeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.beforeState = Any.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.afterState = Any.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.changedFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityChangeEvent {
    return {
      $type: EntityChangeEvent.$type,
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      changeType: isSet(object.changeType) ? changeTypeFromJSON(object.changeType) : 0,
      beforeState: isSet(object.beforeState) ? Any.fromJSON(object.beforeState) : undefined,
      afterState: isSet(object.afterState) ? Any.fromJSON(object.afterState) : undefined,
      changedFields: globalThis.Array.isArray(object?.changedFields)
        ? object.changedFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EntityChangeEvent): unknown {
    const obj: any = {};
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.changeType !== 0) {
      obj.changeType = changeTypeToJSON(message.changeType);
    }
    if (message.beforeState !== undefined) {
      obj.beforeState = Any.toJSON(message.beforeState);
    }
    if (message.afterState !== undefined) {
      obj.afterState = Any.toJSON(message.afterState);
    }
    if (message.changedFields?.length) {
      obj.changedFields = message.changedFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EntityChangeEvent>, I>>(base?: I): EntityChangeEvent {
    return EntityChangeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EntityChangeEvent>, I>>(object: I): EntityChangeEvent {
    const message = createBaseEntityChangeEvent();
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.changeType = object.changeType ?? 0;
    message.beforeState = (object.beforeState !== undefined && object.beforeState !== null)
      ? Any.fromPartial(object.beforeState)
      : undefined;
    message.afterState = (object.afterState !== undefined && object.afterState !== null)
      ? Any.fromPartial(object.afterState)
      : undefined;
    message.changedFields = object.changedFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkflowEvent(): WorkflowEvent {
  return {
    $type: "giftduels.shared.v1.WorkflowEvent",
    workflowId: "",
    workflowType: "",
    status: 0,
    stepName: "",
    context: undefined,
    errorMessage: "",
  };
}

export const WorkflowEvent: MessageFns<WorkflowEvent, "giftduels.shared.v1.WorkflowEvent"> = {
  $type: "giftduels.shared.v1.WorkflowEvent" as const,

  encode(message: WorkflowEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.workflowType !== "") {
      writer.uint32(18).string(message.workflowType);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.stepName !== "") {
      writer.uint32(34).string(message.stepName);
    }
    if (message.context !== undefined) {
      Any.encode(message.context, writer.uint32(42).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(50).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stepName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.context = Any.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowEvent {
    return {
      $type: WorkflowEvent.$type,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowType: isSet(object.workflowType) ? globalThis.String(object.workflowType) : "",
      status: isSet(object.status) ? workflowStatusFromJSON(object.status) : 0,
      stepName: isSet(object.stepName) ? globalThis.String(object.stepName) : "",
      context: isSet(object.context) ? Any.fromJSON(object.context) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: WorkflowEvent): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowType !== "") {
      obj.workflowType = message.workflowType;
    }
    if (message.status !== 0) {
      obj.status = workflowStatusToJSON(message.status);
    }
    if (message.stepName !== "") {
      obj.stepName = message.stepName;
    }
    if (message.context !== undefined) {
      obj.context = Any.toJSON(message.context);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowEvent>, I>>(base?: I): WorkflowEvent {
    return WorkflowEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowEvent>, I>>(object: I): WorkflowEvent {
    const message = createBaseWorkflowEvent();
    message.workflowId = object.workflowId ?? "";
    message.workflowType = object.workflowType ?? "";
    message.status = object.status ?? 0;
    message.stepName = object.stepName ?? "";
    message.context = (object.context !== undefined && object.context !== null)
      ? Any.fromPartial(object.context)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseNotificationEvent(): NotificationEvent {
  return {
    $type: "giftduels.shared.v1.NotificationEvent",
    notificationId: "",
    type: 0,
    recipientTelegramId: "0",
    title: "",
    message: "",
    data: undefined,
    channel: 0,
  };
}

export const NotificationEvent: MessageFns<NotificationEvent, "giftduels.shared.v1.NotificationEvent"> = {
  $type: "giftduels.shared.v1.NotificationEvent" as const,

  encode(message: NotificationEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notificationId !== "") {
      writer.uint32(10).string(message.notificationId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.recipientTelegramId !== "0") {
      writer.uint32(24).int64(message.recipientTelegramId);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(42).string(message.message);
    }
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(50).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(56).int32(message.channel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recipientTelegramId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationEvent {
    return {
      $type: NotificationEvent.$type,
      notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "",
      type: isSet(object.type) ? notificationTypeFromJSON(object.type) : 0,
      recipientTelegramId: isSet(object.recipientTelegramId) ? globalThis.String(object.recipientTelegramId) : "0",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      channel: isSet(object.channel) ? notificationChannelFromJSON(object.channel) : 0,
    };
  },

  toJSON(message: NotificationEvent): unknown {
    const obj: any = {};
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    if (message.type !== 0) {
      obj.type = notificationTypeToJSON(message.type);
    }
    if (message.recipientTelegramId !== "0") {
      obj.recipientTelegramId = message.recipientTelegramId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.channel !== 0) {
      obj.channel = notificationChannelToJSON(message.channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationEvent>, I>>(base?: I): NotificationEvent {
    return NotificationEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationEvent>, I>>(object: I): NotificationEvent {
    const message = createBaseNotificationEvent();
    message.notificationId = object.notificationId ?? "";
    message.type = object.type ?? 0;
    message.recipientTelegramId = object.recipientTelegramId ?? "0";
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.channel = object.channel ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
