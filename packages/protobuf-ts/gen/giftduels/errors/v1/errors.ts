// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/errors/v1/errors.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export enum ErrorCategory {
  ERROR_CATEGORY_UNSPECIFIED = 0,
  ERROR_CATEGORY_VALIDATION = 1,
  ERROR_CATEGORY_AUTHENTICATION = 2,
  ERROR_CATEGORY_AUTHORIZATION = 3,
  ERROR_CATEGORY_NOT_FOUND = 4,
  ERROR_CATEGORY_CONFLICT = 5,
  ERROR_CATEGORY_RESOURCE = 6,
  ERROR_CATEGORY_BUSINESS_LOGIC = 7,
  ERROR_CATEGORY_EXTERNAL_SERVICE = 8,
  ERROR_CATEGORY_INTERNAL = 9,
  UNRECOGNIZED = -1,
}

export function errorCategoryFromJSON(object: any): ErrorCategory {
  switch (object) {
    case 0:
    case "ERROR_CATEGORY_UNSPECIFIED":
      return ErrorCategory.ERROR_CATEGORY_UNSPECIFIED;
    case 1:
    case "ERROR_CATEGORY_VALIDATION":
      return ErrorCategory.ERROR_CATEGORY_VALIDATION;
    case 2:
    case "ERROR_CATEGORY_AUTHENTICATION":
      return ErrorCategory.ERROR_CATEGORY_AUTHENTICATION;
    case 3:
    case "ERROR_CATEGORY_AUTHORIZATION":
      return ErrorCategory.ERROR_CATEGORY_AUTHORIZATION;
    case 4:
    case "ERROR_CATEGORY_NOT_FOUND":
      return ErrorCategory.ERROR_CATEGORY_NOT_FOUND;
    case 5:
    case "ERROR_CATEGORY_CONFLICT":
      return ErrorCategory.ERROR_CATEGORY_CONFLICT;
    case 6:
    case "ERROR_CATEGORY_RESOURCE":
      return ErrorCategory.ERROR_CATEGORY_RESOURCE;
    case 7:
    case "ERROR_CATEGORY_BUSINESS_LOGIC":
      return ErrorCategory.ERROR_CATEGORY_BUSINESS_LOGIC;
    case 8:
    case "ERROR_CATEGORY_EXTERNAL_SERVICE":
      return ErrorCategory.ERROR_CATEGORY_EXTERNAL_SERVICE;
    case 9:
    case "ERROR_CATEGORY_INTERNAL":
      return ErrorCategory.ERROR_CATEGORY_INTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCategory.UNRECOGNIZED;
  }
}

export function errorCategoryToJSON(object: ErrorCategory): string {
  switch (object) {
    case ErrorCategory.ERROR_CATEGORY_UNSPECIFIED:
      return "ERROR_CATEGORY_UNSPECIFIED";
    case ErrorCategory.ERROR_CATEGORY_VALIDATION:
      return "ERROR_CATEGORY_VALIDATION";
    case ErrorCategory.ERROR_CATEGORY_AUTHENTICATION:
      return "ERROR_CATEGORY_AUTHENTICATION";
    case ErrorCategory.ERROR_CATEGORY_AUTHORIZATION:
      return "ERROR_CATEGORY_AUTHORIZATION";
    case ErrorCategory.ERROR_CATEGORY_NOT_FOUND:
      return "ERROR_CATEGORY_NOT_FOUND";
    case ErrorCategory.ERROR_CATEGORY_CONFLICT:
      return "ERROR_CATEGORY_CONFLICT";
    case ErrorCategory.ERROR_CATEGORY_RESOURCE:
      return "ERROR_CATEGORY_RESOURCE";
    case ErrorCategory.ERROR_CATEGORY_BUSINESS_LOGIC:
      return "ERROR_CATEGORY_BUSINESS_LOGIC";
    case ErrorCategory.ERROR_CATEGORY_EXTERNAL_SERVICE:
      return "ERROR_CATEGORY_EXTERNAL_SERVICE";
    case ErrorCategory.ERROR_CATEGORY_INTERNAL:
      return "ERROR_CATEGORY_INTERNAL";
    case ErrorCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  /** ERROR_CODE_VALIDATION_GENERAL - Validation errors (100-199) */
  ERROR_CODE_VALIDATION_GENERAL = 100,
  ERROR_CODE_REQUIRED_FIELD = 101,
  ERROR_CODE_INVALID_FORMAT = 102,
  ERROR_CODE_VALUE_TOO_SMALL = 103,
  ERROR_CODE_VALUE_TOO_LARGE = 104,
  ERROR_CODE_INVALID_EMAIL = 105,
  ERROR_CODE_INVALID_URL = 106,
  ERROR_CODE_INVALID_UUID = 107,
  ERROR_CODE_INVALID_ENUM_VALUE = 108,
  ERROR_CODE_FIELD_TOO_SHORT = 109,
  ERROR_CODE_FIELD_TOO_LONG = 110,
  /** ERROR_CODE_UNAUTHORIZED - Authentication errors (200-299) */
  ERROR_CODE_UNAUTHORIZED = 200,
  ERROR_CODE_INVALID_TOKEN = 201,
  ERROR_CODE_TOKEN_EXPIRED = 202,
  ERROR_CODE_INVALID_CREDENTIALS = 203,
  ERROR_CODE_ACCOUNT_SUSPENDED = 204,
  /** ERROR_CODE_FORBIDDEN - Authorization errors (300-399) */
  ERROR_CODE_FORBIDDEN = 300,
  ERROR_CODE_INSUFFICIENT_PERMISSIONS = 301,
  ERROR_CODE_RESOURCE_ACCESS_DENIED = 302,
  ERROR_CODE_GIFT_NOT_OWNED = 303,
  ERROR_CODE_DUEL_ACCESS_DENIED = 304,
  /** ERROR_CODE_NOT_FOUND - Not found errors (400-499) */
  ERROR_CODE_NOT_FOUND = 400,
  ERROR_CODE_USER_NOT_FOUND = 401,
  ERROR_CODE_GIFT_NOT_FOUND = 402,
  ERROR_CODE_DUEL_NOT_FOUND = 403,
  ERROR_CODE_TRANSACTION_NOT_FOUND = 404,
  ERROR_CODE_INVOICE_NOT_FOUND = 405,
  /** ERROR_CODE_ALREADY_EXISTS - Conflict errors (500-599) */
  ERROR_CODE_ALREADY_EXISTS = 500,
  ERROR_CODE_USER_ALREADY_EXISTS = 501,
  ERROR_CODE_DUEL_ALREADY_JOINED = 502,
  ERROR_CODE_GIFT_ALREADY_STAKED = 503,
  ERROR_CODE_INVALID_STATE_TRANSITION = 504,
  /** ERROR_CODE_INSUFFICIENT_BALANCE - Resource errors (600-699) */
  ERROR_CODE_INSUFFICIENT_BALANCE = 600,
  ERROR_CODE_INSUFFICIENT_STARS = 601,
  ERROR_CODE_INSUFFICIENT_TON = 602,
  ERROR_CODE_GIFT_NOT_AVAILABLE = 603,
  ERROR_CODE_DUEL_FULL = 604,
  ERROR_CODE_RATE_LIMIT_EXCEEDED = 605,
  /** ERROR_CODE_GAME_ALREADY_STARTED - Business logic errors (700-799) */
  ERROR_CODE_GAME_ALREADY_STARTED = 700,
  ERROR_CODE_GAME_ALREADY_FINISHED = 701,
  ERROR_CODE_INVALID_MOVE = 702,
  ERROR_CODE_TIMEOUT_EXCEEDED = 703,
  ERROR_CODE_MINIMUM_STAKE_NOT_MET = 704,
  ERROR_CODE_MAXIMUM_STAKE_EXCEEDED = 705,
  /** ERROR_CODE_TELEGRAM_API_ERROR - External service errors (800-899) */
  ERROR_CODE_TELEGRAM_API_ERROR = 800,
  ERROR_CODE_TON_BLOCKCHAIN_ERROR = 801,
  ERROR_CODE_PAYMENT_PROVIDER_ERROR = 802,
  ERROR_CODE_EXTERNAL_TIMEOUT = 803,
  /** ERROR_CODE_INTERNAL - Internal errors (900-999) */
  ERROR_CODE_INTERNAL = 900,
  ERROR_CODE_DATABASE_ERROR = 901,
  ERROR_CODE_SERVICE_UNAVAILABLE = 902,
  ERROR_CODE_CONFIGURATION_ERROR = 903,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 100:
    case "ERROR_CODE_VALIDATION_GENERAL":
      return ErrorCode.ERROR_CODE_VALIDATION_GENERAL;
    case 101:
    case "ERROR_CODE_REQUIRED_FIELD":
      return ErrorCode.ERROR_CODE_REQUIRED_FIELD;
    case 102:
    case "ERROR_CODE_INVALID_FORMAT":
      return ErrorCode.ERROR_CODE_INVALID_FORMAT;
    case 103:
    case "ERROR_CODE_VALUE_TOO_SMALL":
      return ErrorCode.ERROR_CODE_VALUE_TOO_SMALL;
    case 104:
    case "ERROR_CODE_VALUE_TOO_LARGE":
      return ErrorCode.ERROR_CODE_VALUE_TOO_LARGE;
    case 105:
    case "ERROR_CODE_INVALID_EMAIL":
      return ErrorCode.ERROR_CODE_INVALID_EMAIL;
    case 106:
    case "ERROR_CODE_INVALID_URL":
      return ErrorCode.ERROR_CODE_INVALID_URL;
    case 107:
    case "ERROR_CODE_INVALID_UUID":
      return ErrorCode.ERROR_CODE_INVALID_UUID;
    case 108:
    case "ERROR_CODE_INVALID_ENUM_VALUE":
      return ErrorCode.ERROR_CODE_INVALID_ENUM_VALUE;
    case 109:
    case "ERROR_CODE_FIELD_TOO_SHORT":
      return ErrorCode.ERROR_CODE_FIELD_TOO_SHORT;
    case 110:
    case "ERROR_CODE_FIELD_TOO_LONG":
      return ErrorCode.ERROR_CODE_FIELD_TOO_LONG;
    case 200:
    case "ERROR_CODE_UNAUTHORIZED":
      return ErrorCode.ERROR_CODE_UNAUTHORIZED;
    case 201:
    case "ERROR_CODE_INVALID_TOKEN":
      return ErrorCode.ERROR_CODE_INVALID_TOKEN;
    case 202:
    case "ERROR_CODE_TOKEN_EXPIRED":
      return ErrorCode.ERROR_CODE_TOKEN_EXPIRED;
    case 203:
    case "ERROR_CODE_INVALID_CREDENTIALS":
      return ErrorCode.ERROR_CODE_INVALID_CREDENTIALS;
    case 204:
    case "ERROR_CODE_ACCOUNT_SUSPENDED":
      return ErrorCode.ERROR_CODE_ACCOUNT_SUSPENDED;
    case 300:
    case "ERROR_CODE_FORBIDDEN":
      return ErrorCode.ERROR_CODE_FORBIDDEN;
    case 301:
    case "ERROR_CODE_INSUFFICIENT_PERMISSIONS":
      return ErrorCode.ERROR_CODE_INSUFFICIENT_PERMISSIONS;
    case 302:
    case "ERROR_CODE_RESOURCE_ACCESS_DENIED":
      return ErrorCode.ERROR_CODE_RESOURCE_ACCESS_DENIED;
    case 303:
    case "ERROR_CODE_GIFT_NOT_OWNED":
      return ErrorCode.ERROR_CODE_GIFT_NOT_OWNED;
    case 304:
    case "ERROR_CODE_DUEL_ACCESS_DENIED":
      return ErrorCode.ERROR_CODE_DUEL_ACCESS_DENIED;
    case 400:
    case "ERROR_CODE_NOT_FOUND":
      return ErrorCode.ERROR_CODE_NOT_FOUND;
    case 401:
    case "ERROR_CODE_USER_NOT_FOUND":
      return ErrorCode.ERROR_CODE_USER_NOT_FOUND;
    case 402:
    case "ERROR_CODE_GIFT_NOT_FOUND":
      return ErrorCode.ERROR_CODE_GIFT_NOT_FOUND;
    case 403:
    case "ERROR_CODE_DUEL_NOT_FOUND":
      return ErrorCode.ERROR_CODE_DUEL_NOT_FOUND;
    case 404:
    case "ERROR_CODE_TRANSACTION_NOT_FOUND":
      return ErrorCode.ERROR_CODE_TRANSACTION_NOT_FOUND;
    case 405:
    case "ERROR_CODE_INVOICE_NOT_FOUND":
      return ErrorCode.ERROR_CODE_INVOICE_NOT_FOUND;
    case 500:
    case "ERROR_CODE_ALREADY_EXISTS":
      return ErrorCode.ERROR_CODE_ALREADY_EXISTS;
    case 501:
    case "ERROR_CODE_USER_ALREADY_EXISTS":
      return ErrorCode.ERROR_CODE_USER_ALREADY_EXISTS;
    case 502:
    case "ERROR_CODE_DUEL_ALREADY_JOINED":
      return ErrorCode.ERROR_CODE_DUEL_ALREADY_JOINED;
    case 503:
    case "ERROR_CODE_GIFT_ALREADY_STAKED":
      return ErrorCode.ERROR_CODE_GIFT_ALREADY_STAKED;
    case 504:
    case "ERROR_CODE_INVALID_STATE_TRANSITION":
      return ErrorCode.ERROR_CODE_INVALID_STATE_TRANSITION;
    case 600:
    case "ERROR_CODE_INSUFFICIENT_BALANCE":
      return ErrorCode.ERROR_CODE_INSUFFICIENT_BALANCE;
    case 601:
    case "ERROR_CODE_INSUFFICIENT_STARS":
      return ErrorCode.ERROR_CODE_INSUFFICIENT_STARS;
    case 602:
    case "ERROR_CODE_INSUFFICIENT_TON":
      return ErrorCode.ERROR_CODE_INSUFFICIENT_TON;
    case 603:
    case "ERROR_CODE_GIFT_NOT_AVAILABLE":
      return ErrorCode.ERROR_CODE_GIFT_NOT_AVAILABLE;
    case 604:
    case "ERROR_CODE_DUEL_FULL":
      return ErrorCode.ERROR_CODE_DUEL_FULL;
    case 605:
    case "ERROR_CODE_RATE_LIMIT_EXCEEDED":
      return ErrorCode.ERROR_CODE_RATE_LIMIT_EXCEEDED;
    case 700:
    case "ERROR_CODE_GAME_ALREADY_STARTED":
      return ErrorCode.ERROR_CODE_GAME_ALREADY_STARTED;
    case 701:
    case "ERROR_CODE_GAME_ALREADY_FINISHED":
      return ErrorCode.ERROR_CODE_GAME_ALREADY_FINISHED;
    case 702:
    case "ERROR_CODE_INVALID_MOVE":
      return ErrorCode.ERROR_CODE_INVALID_MOVE;
    case 703:
    case "ERROR_CODE_TIMEOUT_EXCEEDED":
      return ErrorCode.ERROR_CODE_TIMEOUT_EXCEEDED;
    case 704:
    case "ERROR_CODE_MINIMUM_STAKE_NOT_MET":
      return ErrorCode.ERROR_CODE_MINIMUM_STAKE_NOT_MET;
    case 705:
    case "ERROR_CODE_MAXIMUM_STAKE_EXCEEDED":
      return ErrorCode.ERROR_CODE_MAXIMUM_STAKE_EXCEEDED;
    case 800:
    case "ERROR_CODE_TELEGRAM_API_ERROR":
      return ErrorCode.ERROR_CODE_TELEGRAM_API_ERROR;
    case 801:
    case "ERROR_CODE_TON_BLOCKCHAIN_ERROR":
      return ErrorCode.ERROR_CODE_TON_BLOCKCHAIN_ERROR;
    case 802:
    case "ERROR_CODE_PAYMENT_PROVIDER_ERROR":
      return ErrorCode.ERROR_CODE_PAYMENT_PROVIDER_ERROR;
    case 803:
    case "ERROR_CODE_EXTERNAL_TIMEOUT":
      return ErrorCode.ERROR_CODE_EXTERNAL_TIMEOUT;
    case 900:
    case "ERROR_CODE_INTERNAL":
      return ErrorCode.ERROR_CODE_INTERNAL;
    case 901:
    case "ERROR_CODE_DATABASE_ERROR":
      return ErrorCode.ERROR_CODE_DATABASE_ERROR;
    case 902:
    case "ERROR_CODE_SERVICE_UNAVAILABLE":
      return ErrorCode.ERROR_CODE_SERVICE_UNAVAILABLE;
    case 903:
    case "ERROR_CODE_CONFIGURATION_ERROR":
      return ErrorCode.ERROR_CODE_CONFIGURATION_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case ErrorCode.ERROR_CODE_VALIDATION_GENERAL:
      return "ERROR_CODE_VALIDATION_GENERAL";
    case ErrorCode.ERROR_CODE_REQUIRED_FIELD:
      return "ERROR_CODE_REQUIRED_FIELD";
    case ErrorCode.ERROR_CODE_INVALID_FORMAT:
      return "ERROR_CODE_INVALID_FORMAT";
    case ErrorCode.ERROR_CODE_VALUE_TOO_SMALL:
      return "ERROR_CODE_VALUE_TOO_SMALL";
    case ErrorCode.ERROR_CODE_VALUE_TOO_LARGE:
      return "ERROR_CODE_VALUE_TOO_LARGE";
    case ErrorCode.ERROR_CODE_INVALID_EMAIL:
      return "ERROR_CODE_INVALID_EMAIL";
    case ErrorCode.ERROR_CODE_INVALID_URL:
      return "ERROR_CODE_INVALID_URL";
    case ErrorCode.ERROR_CODE_INVALID_UUID:
      return "ERROR_CODE_INVALID_UUID";
    case ErrorCode.ERROR_CODE_INVALID_ENUM_VALUE:
      return "ERROR_CODE_INVALID_ENUM_VALUE";
    case ErrorCode.ERROR_CODE_FIELD_TOO_SHORT:
      return "ERROR_CODE_FIELD_TOO_SHORT";
    case ErrorCode.ERROR_CODE_FIELD_TOO_LONG:
      return "ERROR_CODE_FIELD_TOO_LONG";
    case ErrorCode.ERROR_CODE_UNAUTHORIZED:
      return "ERROR_CODE_UNAUTHORIZED";
    case ErrorCode.ERROR_CODE_INVALID_TOKEN:
      return "ERROR_CODE_INVALID_TOKEN";
    case ErrorCode.ERROR_CODE_TOKEN_EXPIRED:
      return "ERROR_CODE_TOKEN_EXPIRED";
    case ErrorCode.ERROR_CODE_INVALID_CREDENTIALS:
      return "ERROR_CODE_INVALID_CREDENTIALS";
    case ErrorCode.ERROR_CODE_ACCOUNT_SUSPENDED:
      return "ERROR_CODE_ACCOUNT_SUSPENDED";
    case ErrorCode.ERROR_CODE_FORBIDDEN:
      return "ERROR_CODE_FORBIDDEN";
    case ErrorCode.ERROR_CODE_INSUFFICIENT_PERMISSIONS:
      return "ERROR_CODE_INSUFFICIENT_PERMISSIONS";
    case ErrorCode.ERROR_CODE_RESOURCE_ACCESS_DENIED:
      return "ERROR_CODE_RESOURCE_ACCESS_DENIED";
    case ErrorCode.ERROR_CODE_GIFT_NOT_OWNED:
      return "ERROR_CODE_GIFT_NOT_OWNED";
    case ErrorCode.ERROR_CODE_DUEL_ACCESS_DENIED:
      return "ERROR_CODE_DUEL_ACCESS_DENIED";
    case ErrorCode.ERROR_CODE_NOT_FOUND:
      return "ERROR_CODE_NOT_FOUND";
    case ErrorCode.ERROR_CODE_USER_NOT_FOUND:
      return "ERROR_CODE_USER_NOT_FOUND";
    case ErrorCode.ERROR_CODE_GIFT_NOT_FOUND:
      return "ERROR_CODE_GIFT_NOT_FOUND";
    case ErrorCode.ERROR_CODE_DUEL_NOT_FOUND:
      return "ERROR_CODE_DUEL_NOT_FOUND";
    case ErrorCode.ERROR_CODE_TRANSACTION_NOT_FOUND:
      return "ERROR_CODE_TRANSACTION_NOT_FOUND";
    case ErrorCode.ERROR_CODE_INVOICE_NOT_FOUND:
      return "ERROR_CODE_INVOICE_NOT_FOUND";
    case ErrorCode.ERROR_CODE_ALREADY_EXISTS:
      return "ERROR_CODE_ALREADY_EXISTS";
    case ErrorCode.ERROR_CODE_USER_ALREADY_EXISTS:
      return "ERROR_CODE_USER_ALREADY_EXISTS";
    case ErrorCode.ERROR_CODE_DUEL_ALREADY_JOINED:
      return "ERROR_CODE_DUEL_ALREADY_JOINED";
    case ErrorCode.ERROR_CODE_GIFT_ALREADY_STAKED:
      return "ERROR_CODE_GIFT_ALREADY_STAKED";
    case ErrorCode.ERROR_CODE_INVALID_STATE_TRANSITION:
      return "ERROR_CODE_INVALID_STATE_TRANSITION";
    case ErrorCode.ERROR_CODE_INSUFFICIENT_BALANCE:
      return "ERROR_CODE_INSUFFICIENT_BALANCE";
    case ErrorCode.ERROR_CODE_INSUFFICIENT_STARS:
      return "ERROR_CODE_INSUFFICIENT_STARS";
    case ErrorCode.ERROR_CODE_INSUFFICIENT_TON:
      return "ERROR_CODE_INSUFFICIENT_TON";
    case ErrorCode.ERROR_CODE_GIFT_NOT_AVAILABLE:
      return "ERROR_CODE_GIFT_NOT_AVAILABLE";
    case ErrorCode.ERROR_CODE_DUEL_FULL:
      return "ERROR_CODE_DUEL_FULL";
    case ErrorCode.ERROR_CODE_RATE_LIMIT_EXCEEDED:
      return "ERROR_CODE_RATE_LIMIT_EXCEEDED";
    case ErrorCode.ERROR_CODE_GAME_ALREADY_STARTED:
      return "ERROR_CODE_GAME_ALREADY_STARTED";
    case ErrorCode.ERROR_CODE_GAME_ALREADY_FINISHED:
      return "ERROR_CODE_GAME_ALREADY_FINISHED";
    case ErrorCode.ERROR_CODE_INVALID_MOVE:
      return "ERROR_CODE_INVALID_MOVE";
    case ErrorCode.ERROR_CODE_TIMEOUT_EXCEEDED:
      return "ERROR_CODE_TIMEOUT_EXCEEDED";
    case ErrorCode.ERROR_CODE_MINIMUM_STAKE_NOT_MET:
      return "ERROR_CODE_MINIMUM_STAKE_NOT_MET";
    case ErrorCode.ERROR_CODE_MAXIMUM_STAKE_EXCEEDED:
      return "ERROR_CODE_MAXIMUM_STAKE_EXCEEDED";
    case ErrorCode.ERROR_CODE_TELEGRAM_API_ERROR:
      return "ERROR_CODE_TELEGRAM_API_ERROR";
    case ErrorCode.ERROR_CODE_TON_BLOCKCHAIN_ERROR:
      return "ERROR_CODE_TON_BLOCKCHAIN_ERROR";
    case ErrorCode.ERROR_CODE_PAYMENT_PROVIDER_ERROR:
      return "ERROR_CODE_PAYMENT_PROVIDER_ERROR";
    case ErrorCode.ERROR_CODE_EXTERNAL_TIMEOUT:
      return "ERROR_CODE_EXTERNAL_TIMEOUT";
    case ErrorCode.ERROR_CODE_INTERNAL:
      return "ERROR_CODE_INTERNAL";
    case ErrorCode.ERROR_CODE_DATABASE_ERROR:
      return "ERROR_CODE_DATABASE_ERROR";
    case ErrorCode.ERROR_CODE_SERVICE_UNAVAILABLE:
      return "ERROR_CODE_SERVICE_UNAVAILABLE";
    case ErrorCode.ERROR_CODE_CONFIGURATION_ERROR:
      return "ERROR_CODE_CONFIGURATION_ERROR";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ErrorSeverity {
  ERROR_SEVERITY_UNSPECIFIED = 0,
  /** ERROR_SEVERITY_LOW - Warnings, non-critical issues */
  ERROR_SEVERITY_LOW = 1,
  /** ERROR_SEVERITY_MEDIUM - User errors, recoverable issues */
  ERROR_SEVERITY_MEDIUM = 2,
  /** ERROR_SEVERITY_HIGH - System errors, need attention */
  ERROR_SEVERITY_HIGH = 3,
  /** ERROR_SEVERITY_CRITICAL - Service outages, data corruption */
  ERROR_SEVERITY_CRITICAL = 4,
  UNRECOGNIZED = -1,
}

export function errorSeverityFromJSON(object: any): ErrorSeverity {
  switch (object) {
    case 0:
    case "ERROR_SEVERITY_UNSPECIFIED":
      return ErrorSeverity.ERROR_SEVERITY_UNSPECIFIED;
    case 1:
    case "ERROR_SEVERITY_LOW":
      return ErrorSeverity.ERROR_SEVERITY_LOW;
    case 2:
    case "ERROR_SEVERITY_MEDIUM":
      return ErrorSeverity.ERROR_SEVERITY_MEDIUM;
    case 3:
    case "ERROR_SEVERITY_HIGH":
      return ErrorSeverity.ERROR_SEVERITY_HIGH;
    case 4:
    case "ERROR_SEVERITY_CRITICAL":
      return ErrorSeverity.ERROR_SEVERITY_CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorSeverity.UNRECOGNIZED;
  }
}

export function errorSeverityToJSON(object: ErrorSeverity): string {
  switch (object) {
    case ErrorSeverity.ERROR_SEVERITY_UNSPECIFIED:
      return "ERROR_SEVERITY_UNSPECIFIED";
    case ErrorSeverity.ERROR_SEVERITY_LOW:
      return "ERROR_SEVERITY_LOW";
    case ErrorSeverity.ERROR_SEVERITY_MEDIUM:
      return "ERROR_SEVERITY_MEDIUM";
    case ErrorSeverity.ERROR_SEVERITY_HIGH:
      return "ERROR_SEVERITY_HIGH";
    case ErrorSeverity.ERROR_SEVERITY_CRITICAL:
      return "ERROR_SEVERITY_CRITICAL";
    case ErrorSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ErrorDetail {
  $type: "giftduels.errors.v1.ErrorDetail";
  code: ErrorCode;
  category: ErrorCategory;
  /** Human-readable error message */
  message: string;
  /** Field name for validation errors */
  field: string;
  /** Additional context */
  context:
    | ErrorContext
    | undefined;
  /** For grouped errors */
  nestedErrors: ErrorDetail[];
}

export interface ErrorContext {
  $type: "giftduels.errors.v1.ErrorContext";
  /** Key-value pairs with additional info */
  metadata: { [key: string]: string };
  /** Request trace ID for debugging */
  traceId: string;
  /** ID of the resource that caused the error */
  resourceId: string;
  /** Type of resource (gift, duel, user, etc.) */
  resourceType: string;
}

export interface ErrorContext_MetadataEntry {
  $type: "giftduels.errors.v1.ErrorContext.MetadataEntry";
  key: string;
  value: string;
}

export interface ErrorResponse {
  $type: "giftduels.errors.v1.ErrorResponse";
  /** HTTP status code */
  httpStatus: number;
  /** Unique error identifier for tracking */
  errorId: string;
  /** List of error details */
  details: ErrorDetail[];
  /** User-friendly message */
  userMessage: string;
  /** Technical message for developers */
  developerMessage: string;
  /** Link to error documentation */
  documentationUrl: string;
}

export interface ErrorReport {
  $type: "giftduels.errors.v1.ErrorReport";
  errorId: string;
  severity: ErrorSeverity;
  details: ErrorDetail[];
  context:
    | ErrorContext
    | undefined;
  /** ISO 8601 timestamp */
  timestamp: string;
  userId: string;
  serviceName: string;
}

function createBaseErrorDetail(): ErrorDetail {
  return {
    $type: "giftduels.errors.v1.ErrorDetail",
    code: 0,
    category: 0,
    message: "",
    field: "",
    context: undefined,
    nestedErrors: [],
  };
}

export const ErrorDetail: MessageFns<ErrorDetail, "giftduels.errors.v1.ErrorDetail"> = {
  $type: "giftduels.errors.v1.ErrorDetail" as const,

  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.field !== "") {
      writer.uint32(34).string(message.field);
    }
    if (message.context !== undefined) {
      ErrorContext.encode(message.context, writer.uint32(42).fork()).join();
    }
    for (const v of message.nestedErrors) {
      ErrorDetail.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.context = ErrorContext.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nestedErrors.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      $type: ErrorDetail.$type,
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
      category: isSet(object.category) ? errorCategoryFromJSON(object.category) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      context: isSet(object.context) ? ErrorContext.fromJSON(object.context) : undefined,
      nestedErrors: globalThis.Array.isArray(object?.nestedErrors)
        ? object.nestedErrors.map((e: any) => ErrorDetail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    if (message.category !== 0) {
      obj.category = errorCategoryToJSON(message.category);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.context !== undefined) {
      obj.context = ErrorContext.toJSON(message.context);
    }
    if (message.nestedErrors?.length) {
      obj.nestedErrors = message.nestedErrors.map((e) => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(object: I): ErrorDetail {
    const message = createBaseErrorDetail();
    message.code = object.code ?? 0;
    message.category = object.category ?? 0;
    message.message = object.message ?? "";
    message.field = object.field ?? "";
    message.context = (object.context !== undefined && object.context !== null)
      ? ErrorContext.fromPartial(object.context)
      : undefined;
    message.nestedErrors = object.nestedErrors?.map((e) => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorContext(): ErrorContext {
  return { $type: "giftduels.errors.v1.ErrorContext", metadata: {}, traceId: "", resourceId: "", resourceType: "" };
}

export const ErrorContext: MessageFns<ErrorContext, "giftduels.errors.v1.ErrorContext"> = {
  $type: "giftduels.errors.v1.ErrorContext" as const,

  encode(message: ErrorContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.metadata).forEach(([key, value]) => {
      ErrorContext_MetadataEntry.encode({
        $type: "giftduels.errors.v1.ErrorContext.MetadataEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    if (message.traceId !== "") {
      writer.uint32(18).string(message.traceId);
    }
    if (message.resourceId !== "") {
      writer.uint32(26).string(message.resourceId);
    }
    if (message.resourceType !== "") {
      writer.uint32(34).string(message.resourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ErrorContext_MetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.metadata[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.traceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorContext {
    return {
      $type: ErrorContext.$type,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
    };
  },

  toJSON(message: ErrorContext): unknown {
    const obj: any = {};
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorContext>, I>>(base?: I): ErrorContext {
    return ErrorContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorContext>, I>>(object: I): ErrorContext {
    const message = createBaseErrorContext();
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.traceId = object.traceId ?? "";
    message.resourceId = object.resourceId ?? "";
    message.resourceType = object.resourceType ?? "";
    return message;
  },
};

function createBaseErrorContext_MetadataEntry(): ErrorContext_MetadataEntry {
  return { $type: "giftduels.errors.v1.ErrorContext.MetadataEntry", key: "", value: "" };
}

export const ErrorContext_MetadataEntry: MessageFns<
  ErrorContext_MetadataEntry,
  "giftduels.errors.v1.ErrorContext.MetadataEntry"
> = {
  $type: "giftduels.errors.v1.ErrorContext.MetadataEntry" as const,

  encode(message: ErrorContext_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorContext_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorContext_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorContext_MetadataEntry {
    return {
      $type: ErrorContext_MetadataEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ErrorContext_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorContext_MetadataEntry>, I>>(base?: I): ErrorContext_MetadataEntry {
    return ErrorContext_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorContext_MetadataEntry>, I>>(object: I): ErrorContext_MetadataEntry {
    const message = createBaseErrorContext_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return {
    $type: "giftduels.errors.v1.ErrorResponse",
    httpStatus: 0,
    errorId: "",
    details: [],
    userMessage: "",
    developerMessage: "",
    documentationUrl: "",
  };
}

export const ErrorResponse: MessageFns<ErrorResponse, "giftduels.errors.v1.ErrorResponse"> = {
  $type: "giftduels.errors.v1.ErrorResponse" as const,

  encode(message: ErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpStatus !== 0) {
      writer.uint32(8).int32(message.httpStatus);
    }
    if (message.errorId !== "") {
      writer.uint32(18).string(message.errorId);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.userMessage !== "") {
      writer.uint32(34).string(message.userMessage);
    }
    if (message.developerMessage !== "") {
      writer.uint32(42).string(message.developerMessage);
    }
    if (message.documentationUrl !== "") {
      writer.uint32(50).string(message.documentationUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.httpStatus = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userMessage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.developerMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.documentationUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return {
      $type: ErrorResponse.$type,
      httpStatus: isSet(object.httpStatus) ? globalThis.Number(object.httpStatus) : 0,
      errorId: isSet(object.errorId) ? globalThis.String(object.errorId) : "",
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => ErrorDetail.fromJSON(e)) : [],
      userMessage: isSet(object.userMessage) ? globalThis.String(object.userMessage) : "",
      developerMessage: isSet(object.developerMessage) ? globalThis.String(object.developerMessage) : "",
      documentationUrl: isSet(object.documentationUrl) ? globalThis.String(object.documentationUrl) : "",
    };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.httpStatus !== 0) {
      obj.httpStatus = Math.round(message.httpStatus);
    }
    if (message.errorId !== "") {
      obj.errorId = message.errorId;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ErrorDetail.toJSON(e));
    }
    if (message.userMessage !== "") {
      obj.userMessage = message.userMessage;
    }
    if (message.developerMessage !== "") {
      obj.developerMessage = message.developerMessage;
    }
    if (message.documentationUrl !== "") {
      obj.documentationUrl = message.documentationUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorResponse>, I>>(base?: I): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorResponse>, I>>(object: I): ErrorResponse {
    const message = createBaseErrorResponse();
    message.httpStatus = object.httpStatus ?? 0;
    message.errorId = object.errorId ?? "";
    message.details = object.details?.map((e) => ErrorDetail.fromPartial(e)) || [];
    message.userMessage = object.userMessage ?? "";
    message.developerMessage = object.developerMessage ?? "";
    message.documentationUrl = object.documentationUrl ?? "";
    return message;
  },
};

function createBaseErrorReport(): ErrorReport {
  return {
    $type: "giftduels.errors.v1.ErrorReport",
    errorId: "",
    severity: 0,
    details: [],
    context: undefined,
    timestamp: "",
    userId: "",
    serviceName: "",
  };
}

export const ErrorReport: MessageFns<ErrorReport, "giftduels.errors.v1.ErrorReport"> = {
  $type: "giftduels.errors.v1.ErrorReport" as const,

  encode(message: ErrorReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorId !== "") {
      writer.uint32(10).string(message.errorId);
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.context !== undefined) {
      ErrorContext.encode(message.context, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    if (message.userId !== "") {
      writer.uint32(50).string(message.userId);
    }
    if (message.serviceName !== "") {
      writer.uint32(58).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.context = ErrorContext.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorReport {
    return {
      $type: ErrorReport.$type,
      errorId: isSet(object.errorId) ? globalThis.String(object.errorId) : "",
      severity: isSet(object.severity) ? errorSeverityFromJSON(object.severity) : 0,
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => ErrorDetail.fromJSON(e)) : [],
      context: isSet(object.context) ? ErrorContext.fromJSON(object.context) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
    };
  },

  toJSON(message: ErrorReport): unknown {
    const obj: any = {};
    if (message.errorId !== "") {
      obj.errorId = message.errorId;
    }
    if (message.severity !== 0) {
      obj.severity = errorSeverityToJSON(message.severity);
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ErrorDetail.toJSON(e));
    }
    if (message.context !== undefined) {
      obj.context = ErrorContext.toJSON(message.context);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorReport>, I>>(base?: I): ErrorReport {
    return ErrorReport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorReport>, I>>(object: I): ErrorReport {
    const message = createBaseErrorReport();
    message.errorId = object.errorId ?? "";
    message.severity = object.severity ?? 0;
    message.details = object.details?.map((e) => ErrorDetail.fromPartial(e)) || [];
    message.context = (object.context !== undefined && object.context !== null)
      ? ErrorContext.fromPartial(object.context)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    message.userId = object.userId ?? "";
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
