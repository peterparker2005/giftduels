// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/payment/v1/private_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GiftId, StarsAmount, TelegramUserId, TonAmount } from "../../shared/v1/common";
import { TonWithdrawal } from "./payment";

export interface PrepareTonWithdrawalRequest {
  $type: "giftduels.payment.v1.PrepareTonWithdrawalRequest";
  giftId: GiftId | undefined;
  tonAmount: TonAmount | undefined;
  comment: string;
}

export interface PrepareTonWithdrawalResponse {
  $type: "giftduels.payment.v1.PrepareTonWithdrawalResponse";
  tonWithdrawal: TonWithdrawal | undefined;
}

export interface SpendUserBalanceRequest {
  $type: "giftduels.payment.v1.SpendUserBalanceRequest";
  telegramUserId: TelegramUserId | undefined;
  starsAmount: StarsAmount | undefined;
}

export interface SpendUserBalanceResponse {
  $type: "giftduels.payment.v1.SpendUserBalanceResponse";
  starsAmount: StarsAmount | undefined;
}

export interface GetUserBalanceRequest {
  $type: "giftduels.payment.v1.GetUserBalanceRequest";
  telegramUserId: TelegramUserId | undefined;
}

export interface GetUserBalanceResponse {
  $type: "giftduels.payment.v1.GetUserBalanceResponse";
  starsAmount: StarsAmount | undefined;
}

function createBasePrepareTonWithdrawalRequest(): PrepareTonWithdrawalRequest {
  return {
    $type: "giftduels.payment.v1.PrepareTonWithdrawalRequest",
    giftId: undefined,
    tonAmount: undefined,
    comment: "",
  };
}

export const PrepareTonWithdrawalRequest: MessageFns<
  PrepareTonWithdrawalRequest,
  "giftduels.payment.v1.PrepareTonWithdrawalRequest"
> = {
  $type: "giftduels.payment.v1.PrepareTonWithdrawalRequest" as const,

  encode(message: PrepareTonWithdrawalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.tonAmount !== undefined) {
      TonAmount.encode(message.tonAmount, writer.uint32(18).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareTonWithdrawalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTonWithdrawalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tonAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareTonWithdrawalRequest {
    return {
      $type: PrepareTonWithdrawalRequest.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      tonAmount: isSet(object.tonAmount) ? TonAmount.fromJSON(object.tonAmount) : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: PrepareTonWithdrawalRequest): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.tonAmount !== undefined) {
      obj.tonAmount = TonAmount.toJSON(message.tonAmount);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareTonWithdrawalRequest>, I>>(base?: I): PrepareTonWithdrawalRequest {
    return PrepareTonWithdrawalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareTonWithdrawalRequest>, I>>(object: I): PrepareTonWithdrawalRequest {
    const message = createBasePrepareTonWithdrawalRequest();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.tonAmount = (object.tonAmount !== undefined && object.tonAmount !== null)
      ? TonAmount.fromPartial(object.tonAmount)
      : undefined;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBasePrepareTonWithdrawalResponse(): PrepareTonWithdrawalResponse {
  return { $type: "giftduels.payment.v1.PrepareTonWithdrawalResponse", tonWithdrawal: undefined };
}

export const PrepareTonWithdrawalResponse: MessageFns<
  PrepareTonWithdrawalResponse,
  "giftduels.payment.v1.PrepareTonWithdrawalResponse"
> = {
  $type: "giftduels.payment.v1.PrepareTonWithdrawalResponse" as const,

  encode(message: PrepareTonWithdrawalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tonWithdrawal !== undefined) {
      TonWithdrawal.encode(message.tonWithdrawal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareTonWithdrawalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTonWithdrawalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tonWithdrawal = TonWithdrawal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareTonWithdrawalResponse {
    return {
      $type: PrepareTonWithdrawalResponse.$type,
      tonWithdrawal: isSet(object.tonWithdrawal) ? TonWithdrawal.fromJSON(object.tonWithdrawal) : undefined,
    };
  },

  toJSON(message: PrepareTonWithdrawalResponse): unknown {
    const obj: any = {};
    if (message.tonWithdrawal !== undefined) {
      obj.tonWithdrawal = TonWithdrawal.toJSON(message.tonWithdrawal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareTonWithdrawalResponse>, I>>(base?: I): PrepareTonWithdrawalResponse {
    return PrepareTonWithdrawalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareTonWithdrawalResponse>, I>>(object: I): PrepareTonWithdrawalResponse {
    const message = createBasePrepareTonWithdrawalResponse();
    message.tonWithdrawal = (object.tonWithdrawal !== undefined && object.tonWithdrawal !== null)
      ? TonWithdrawal.fromPartial(object.tonWithdrawal)
      : undefined;
    return message;
  },
};

function createBaseSpendUserBalanceRequest(): SpendUserBalanceRequest {
  return { $type: "giftduels.payment.v1.SpendUserBalanceRequest", telegramUserId: undefined, starsAmount: undefined };
}

export const SpendUserBalanceRequest: MessageFns<
  SpendUserBalanceRequest,
  "giftduels.payment.v1.SpendUserBalanceRequest"
> = {
  $type: "giftduels.payment.v1.SpendUserBalanceRequest" as const,

  encode(message: SpendUserBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.telegramUserId !== undefined) {
      TelegramUserId.encode(message.telegramUserId, writer.uint32(10).fork()).join();
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendUserBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendUserBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.telegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendUserBalanceRequest {
    return {
      $type: SpendUserBalanceRequest.$type,
      telegramUserId: isSet(object.telegramUserId) ? TelegramUserId.fromJSON(object.telegramUserId) : undefined,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
    };
  },

  toJSON(message: SpendUserBalanceRequest): unknown {
    const obj: any = {};
    if (message.telegramUserId !== undefined) {
      obj.telegramUserId = TelegramUserId.toJSON(message.telegramUserId);
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendUserBalanceRequest>, I>>(base?: I): SpendUserBalanceRequest {
    return SpendUserBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendUserBalanceRequest>, I>>(object: I): SpendUserBalanceRequest {
    const message = createBaseSpendUserBalanceRequest();
    message.telegramUserId = (object.telegramUserId !== undefined && object.telegramUserId !== null)
      ? TelegramUserId.fromPartial(object.telegramUserId)
      : undefined;
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    return message;
  },
};

function createBaseSpendUserBalanceResponse(): SpendUserBalanceResponse {
  return { $type: "giftduels.payment.v1.SpendUserBalanceResponse", starsAmount: undefined };
}

export const SpendUserBalanceResponse: MessageFns<
  SpendUserBalanceResponse,
  "giftduels.payment.v1.SpendUserBalanceResponse"
> = {
  $type: "giftduels.payment.v1.SpendUserBalanceResponse" as const,

  encode(message: SpendUserBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendUserBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendUserBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendUserBalanceResponse {
    return {
      $type: SpendUserBalanceResponse.$type,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
    };
  },

  toJSON(message: SpendUserBalanceResponse): unknown {
    const obj: any = {};
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendUserBalanceResponse>, I>>(base?: I): SpendUserBalanceResponse {
    return SpendUserBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendUserBalanceResponse>, I>>(object: I): SpendUserBalanceResponse {
    const message = createBaseSpendUserBalanceResponse();
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    return message;
  },
};

function createBaseGetUserBalanceRequest(): GetUserBalanceRequest {
  return { $type: "giftduels.payment.v1.GetUserBalanceRequest", telegramUserId: undefined };
}

export const GetUserBalanceRequest: MessageFns<GetUserBalanceRequest, "giftduels.payment.v1.GetUserBalanceRequest"> = {
  $type: "giftduels.payment.v1.GetUserBalanceRequest" as const,

  encode(message: GetUserBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.telegramUserId !== undefined) {
      TelegramUserId.encode(message.telegramUserId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.telegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserBalanceRequest {
    return {
      $type: GetUserBalanceRequest.$type,
      telegramUserId: isSet(object.telegramUserId) ? TelegramUserId.fromJSON(object.telegramUserId) : undefined,
    };
  },

  toJSON(message: GetUserBalanceRequest): unknown {
    const obj: any = {};
    if (message.telegramUserId !== undefined) {
      obj.telegramUserId = TelegramUserId.toJSON(message.telegramUserId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserBalanceRequest>, I>>(base?: I): GetUserBalanceRequest {
    return GetUserBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserBalanceRequest>, I>>(object: I): GetUserBalanceRequest {
    const message = createBaseGetUserBalanceRequest();
    message.telegramUserId = (object.telegramUserId !== undefined && object.telegramUserId !== null)
      ? TelegramUserId.fromPartial(object.telegramUserId)
      : undefined;
    return message;
  },
};

function createBaseGetUserBalanceResponse(): GetUserBalanceResponse {
  return { $type: "giftduels.payment.v1.GetUserBalanceResponse", starsAmount: undefined };
}

export const GetUserBalanceResponse: MessageFns<GetUserBalanceResponse, "giftduels.payment.v1.GetUserBalanceResponse"> =
  {
    $type: "giftduels.payment.v1.GetUserBalanceResponse" as const,

    encode(message: GetUserBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.starsAmount !== undefined) {
        StarsAmount.encode(message.starsAmount, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetUserBalanceResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetUserBalanceResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.starsAmount = StarsAmount.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetUserBalanceResponse {
      return {
        $type: GetUserBalanceResponse.$type,
        starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
      };
    },

    toJSON(message: GetUserBalanceResponse): unknown {
      const obj: any = {};
      if (message.starsAmount !== undefined) {
        obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetUserBalanceResponse>, I>>(base?: I): GetUserBalanceResponse {
      return GetUserBalanceResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetUserBalanceResponse>, I>>(object: I): GetUserBalanceResponse {
      const message = createBaseGetUserBalanceResponse();
      message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
        ? StarsAmount.fromPartial(object.starsAmount)
        : undefined;
      return message;
    },
  };

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
