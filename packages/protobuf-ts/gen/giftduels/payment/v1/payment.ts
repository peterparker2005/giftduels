// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/payment/v1/payment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { GiftId, StarsAmount, TelegramUserId, TonAmount } from "../../shared/v1/common";

export enum InvoicePurpose {
  INVOICE_PURPOSE_UNSPECIFIED = 0,
  /** INVOICE_PURPOSE_STARS_DEPOSIT - user bought/added stars manually */
  INVOICE_PURPOSE_STARS_DEPOSIT = 1,
  /** INVOICE_PURPOSE_GIFT_COMMISSION - automatic fee for gift withdrawal */
  INVOICE_PURPOSE_GIFT_COMMISSION = 2,
  UNRECOGNIZED = -1,
}

export function invoicePurposeFromJSON(object: any): InvoicePurpose {
  switch (object) {
    case 0:
    case "INVOICE_PURPOSE_UNSPECIFIED":
      return InvoicePurpose.INVOICE_PURPOSE_UNSPECIFIED;
    case 1:
    case "INVOICE_PURPOSE_STARS_DEPOSIT":
      return InvoicePurpose.INVOICE_PURPOSE_STARS_DEPOSIT;
    case 2:
    case "INVOICE_PURPOSE_GIFT_COMMISSION":
      return InvoicePurpose.INVOICE_PURPOSE_GIFT_COMMISSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvoicePurpose.UNRECOGNIZED;
  }
}

export function invoicePurposeToJSON(object: InvoicePurpose): string {
  switch (object) {
    case InvoicePurpose.INVOICE_PURPOSE_UNSPECIFIED:
      return "INVOICE_PURPOSE_UNSPECIFIED";
    case InvoicePurpose.INVOICE_PURPOSE_STARS_DEPOSIT:
      return "INVOICE_PURPOSE_STARS_DEPOSIT";
    case InvoicePurpose.INVOICE_PURPOSE_GIFT_COMMISSION:
      return "INVOICE_PURPOSE_GIFT_COMMISSION";
    case InvoicePurpose.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StarTransactionType {
  STAR_TRANSACTION_TYPE_UNSPECIFIED = 0,
  STAR_TRANSACTION_TYPE_INCOME = 1,
  STAR_TRANSACTION_TYPE_EXPENSE = 2,
  UNRECOGNIZED = -1,
}

export function starTransactionTypeFromJSON(object: any): StarTransactionType {
  switch (object) {
    case 0:
    case "STAR_TRANSACTION_TYPE_UNSPECIFIED":
      return StarTransactionType.STAR_TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "STAR_TRANSACTION_TYPE_INCOME":
      return StarTransactionType.STAR_TRANSACTION_TYPE_INCOME;
    case 2:
    case "STAR_TRANSACTION_TYPE_EXPENSE":
      return StarTransactionType.STAR_TRANSACTION_TYPE_EXPENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StarTransactionType.UNRECOGNIZED;
  }
}

export function starTransactionTypeToJSON(object: StarTransactionType): string {
  switch (object) {
    case StarTransactionType.STAR_TRANSACTION_TYPE_UNSPECIFIED:
      return "STAR_TRANSACTION_TYPE_UNSPECIFIED";
    case StarTransactionType.STAR_TRANSACTION_TYPE_INCOME:
      return "STAR_TRANSACTION_TYPE_INCOME";
    case StarTransactionType.STAR_TRANSACTION_TYPE_EXPENSE:
      return "STAR_TRANSACTION_TYPE_EXPENSE";
    case StarTransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StarTransactionSource {
  STAR_TRANSACTION_SOURCE_UNSPECIFIED = 0,
  STAR_TRANSACTION_SOURCE_TELEGRAM_STARS = 1,
  STAR_TRANSACTION_SOURCE_INTERNAL_WALLET = 2,
  STAR_TRANSACTION_SOURCE_REFERRAL_BONUS = 3,
  UNRECOGNIZED = -1,
}

export function starTransactionSourceFromJSON(object: any): StarTransactionSource {
  switch (object) {
    case 0:
    case "STAR_TRANSACTION_SOURCE_UNSPECIFIED":
      return StarTransactionSource.STAR_TRANSACTION_SOURCE_UNSPECIFIED;
    case 1:
    case "STAR_TRANSACTION_SOURCE_TELEGRAM_STARS":
      return StarTransactionSource.STAR_TRANSACTION_SOURCE_TELEGRAM_STARS;
    case 2:
    case "STAR_TRANSACTION_SOURCE_INTERNAL_WALLET":
      return StarTransactionSource.STAR_TRANSACTION_SOURCE_INTERNAL_WALLET;
    case 3:
    case "STAR_TRANSACTION_SOURCE_REFERRAL_BONUS":
      return StarTransactionSource.STAR_TRANSACTION_SOURCE_REFERRAL_BONUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StarTransactionSource.UNRECOGNIZED;
  }
}

export function starTransactionSourceToJSON(object: StarTransactionSource): string {
  switch (object) {
    case StarTransactionSource.STAR_TRANSACTION_SOURCE_UNSPECIFIED:
      return "STAR_TRANSACTION_SOURCE_UNSPECIFIED";
    case StarTransactionSource.STAR_TRANSACTION_SOURCE_TELEGRAM_STARS:
      return "STAR_TRANSACTION_SOURCE_TELEGRAM_STARS";
    case StarTransactionSource.STAR_TRANSACTION_SOURCE_INTERNAL_WALLET:
      return "STAR_TRANSACTION_SOURCE_INTERNAL_WALLET";
    case StarTransactionSource.STAR_TRANSACTION_SOURCE_REFERRAL_BONUS:
      return "STAR_TRANSACTION_SOURCE_REFERRAL_BONUS";
    case StarTransactionSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StarTransactionPurpose {
  STAR_TRANSACTION_PURPOSE_UNSPECIFIED = 0,
  STAR_TRANSACTION_PURPOSE_STARS_DEPOSIT = 1,
  STAR_TRANSACTION_PURPOSE_GIFT_WITHDRAW = 2,
  STAR_TRANSACTION_PURPOSE_GAME_ENTRY_FEE = 3,
  STAR_TRANSACTION_PURPOSE_PRIZE_PAYOUT = 4,
  STAR_TRANSACTION_PURPOSE_REFUND = 5,
  UNRECOGNIZED = -1,
}

export function starTransactionPurposeFromJSON(object: any): StarTransactionPurpose {
  switch (object) {
    case 0:
    case "STAR_TRANSACTION_PURPOSE_UNSPECIFIED":
      return StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_UNSPECIFIED;
    case 1:
    case "STAR_TRANSACTION_PURPOSE_STARS_DEPOSIT":
      return StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_STARS_DEPOSIT;
    case 2:
    case "STAR_TRANSACTION_PURPOSE_GIFT_WITHDRAW":
      return StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_GIFT_WITHDRAW;
    case 3:
    case "STAR_TRANSACTION_PURPOSE_GAME_ENTRY_FEE":
      return StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_GAME_ENTRY_FEE;
    case 4:
    case "STAR_TRANSACTION_PURPOSE_PRIZE_PAYOUT":
      return StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_PRIZE_PAYOUT;
    case 5:
    case "STAR_TRANSACTION_PURPOSE_REFUND":
      return StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_REFUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StarTransactionPurpose.UNRECOGNIZED;
  }
}

export function starTransactionPurposeToJSON(object: StarTransactionPurpose): string {
  switch (object) {
    case StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_UNSPECIFIED:
      return "STAR_TRANSACTION_PURPOSE_UNSPECIFIED";
    case StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_STARS_DEPOSIT:
      return "STAR_TRANSACTION_PURPOSE_STARS_DEPOSIT";
    case StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_GIFT_WITHDRAW:
      return "STAR_TRANSACTION_PURPOSE_GIFT_WITHDRAW";
    case StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_GAME_ENTRY_FEE:
      return "STAR_TRANSACTION_PURPOSE_GAME_ENTRY_FEE";
    case StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_PRIZE_PAYOUT:
      return "STAR_TRANSACTION_PURPOSE_PRIZE_PAYOUT";
    case StarTransactionPurpose.STAR_TRANSACTION_PURPOSE_REFUND:
      return "STAR_TRANSACTION_PURPOSE_REFUND";
    case StarTransactionPurpose.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TonTransactionType {
  TON_TRANSACTION_TYPE_UNSPECIFIED = 0,
  TON_TRANSACTION_TYPE_INCOME = 1,
  TON_TRANSACTION_TYPE_EXPENSE = 2,
  UNRECOGNIZED = -1,
}

export function tonTransactionTypeFromJSON(object: any): TonTransactionType {
  switch (object) {
    case 0:
    case "TON_TRANSACTION_TYPE_UNSPECIFIED":
      return TonTransactionType.TON_TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "TON_TRANSACTION_TYPE_INCOME":
      return TonTransactionType.TON_TRANSACTION_TYPE_INCOME;
    case 2:
    case "TON_TRANSACTION_TYPE_EXPENSE":
      return TonTransactionType.TON_TRANSACTION_TYPE_EXPENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TonTransactionType.UNRECOGNIZED;
  }
}

export function tonTransactionTypeToJSON(object: TonTransactionType): string {
  switch (object) {
    case TonTransactionType.TON_TRANSACTION_TYPE_UNSPECIFIED:
      return "TON_TRANSACTION_TYPE_UNSPECIFIED";
    case TonTransactionType.TON_TRANSACTION_TYPE_INCOME:
      return "TON_TRANSACTION_TYPE_INCOME";
    case TonTransactionType.TON_TRANSACTION_TYPE_EXPENSE:
      return "TON_TRANSACTION_TYPE_EXPENSE";
    case TonTransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TonTransactionPurpose {
  TON_TRANSACTION_PURPOSE_UNSPECIFIED = 0,
  TON_TRANSACTION_PURPOSE_GIFT_WITHDRAW = 1,
  TON_TRANSACTION_PURPOSE_WALLET_DEPOSIT = 2,
  TON_TRANSACTION_PURPOSE_GAME_PRIZE = 3,
  TON_TRANSACTION_PURPOSE_FEE_PAYMENT = 4,
  UNRECOGNIZED = -1,
}

export function tonTransactionPurposeFromJSON(object: any): TonTransactionPurpose {
  switch (object) {
    case 0:
    case "TON_TRANSACTION_PURPOSE_UNSPECIFIED":
      return TonTransactionPurpose.TON_TRANSACTION_PURPOSE_UNSPECIFIED;
    case 1:
    case "TON_TRANSACTION_PURPOSE_GIFT_WITHDRAW":
      return TonTransactionPurpose.TON_TRANSACTION_PURPOSE_GIFT_WITHDRAW;
    case 2:
    case "TON_TRANSACTION_PURPOSE_WALLET_DEPOSIT":
      return TonTransactionPurpose.TON_TRANSACTION_PURPOSE_WALLET_DEPOSIT;
    case 3:
    case "TON_TRANSACTION_PURPOSE_GAME_PRIZE":
      return TonTransactionPurpose.TON_TRANSACTION_PURPOSE_GAME_PRIZE;
    case 4:
    case "TON_TRANSACTION_PURPOSE_FEE_PAYMENT":
      return TonTransactionPurpose.TON_TRANSACTION_PURPOSE_FEE_PAYMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TonTransactionPurpose.UNRECOGNIZED;
  }
}

export function tonTransactionPurposeToJSON(object: TonTransactionPurpose): string {
  switch (object) {
    case TonTransactionPurpose.TON_TRANSACTION_PURPOSE_UNSPECIFIED:
      return "TON_TRANSACTION_PURPOSE_UNSPECIFIED";
    case TonTransactionPurpose.TON_TRANSACTION_PURPOSE_GIFT_WITHDRAW:
      return "TON_TRANSACTION_PURPOSE_GIFT_WITHDRAW";
    case TonTransactionPurpose.TON_TRANSACTION_PURPOSE_WALLET_DEPOSIT:
      return "TON_TRANSACTION_PURPOSE_WALLET_DEPOSIT";
    case TonTransactionPurpose.TON_TRANSACTION_PURPOSE_GAME_PRIZE:
      return "TON_TRANSACTION_PURPOSE_GAME_PRIZE";
    case TonTransactionPurpose.TON_TRANSACTION_PURPOSE_FEE_PAYMENT:
      return "TON_TRANSACTION_PURPOSE_FEE_PAYMENT";
    case TonTransactionPurpose.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TonTransactionStatus {
  TON_TRANSACTION_STATUS_UNSPECIFIED = 0,
  TON_TRANSACTION_STATUS_PENDING = 1,
  TON_TRANSACTION_STATUS_CONFIRMED = 2,
  TON_TRANSACTION_STATUS_FAILED = 3,
  TON_TRANSACTION_STATUS_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function tonTransactionStatusFromJSON(object: any): TonTransactionStatus {
  switch (object) {
    case 0:
    case "TON_TRANSACTION_STATUS_UNSPECIFIED":
      return TonTransactionStatus.TON_TRANSACTION_STATUS_UNSPECIFIED;
    case 1:
    case "TON_TRANSACTION_STATUS_PENDING":
      return TonTransactionStatus.TON_TRANSACTION_STATUS_PENDING;
    case 2:
    case "TON_TRANSACTION_STATUS_CONFIRMED":
      return TonTransactionStatus.TON_TRANSACTION_STATUS_CONFIRMED;
    case 3:
    case "TON_TRANSACTION_STATUS_FAILED":
      return TonTransactionStatus.TON_TRANSACTION_STATUS_FAILED;
    case 4:
    case "TON_TRANSACTION_STATUS_CANCELLED":
      return TonTransactionStatus.TON_TRANSACTION_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TonTransactionStatus.UNRECOGNIZED;
  }
}

export function tonTransactionStatusToJSON(object: TonTransactionStatus): string {
  switch (object) {
    case TonTransactionStatus.TON_TRANSACTION_STATUS_UNSPECIFIED:
      return "TON_TRANSACTION_STATUS_UNSPECIFIED";
    case TonTransactionStatus.TON_TRANSACTION_STATUS_PENDING:
      return "TON_TRANSACTION_STATUS_PENDING";
    case TonTransactionStatus.TON_TRANSACTION_STATUS_CONFIRMED:
      return "TON_TRANSACTION_STATUS_CONFIRMED";
    case TonTransactionStatus.TON_TRANSACTION_STATUS_FAILED:
      return "TON_TRANSACTION_STATUS_FAILED";
    case TonTransactionStatus.TON_TRANSACTION_STATUS_CANCELLED:
      return "TON_TRANSACTION_STATUS_CANCELLED";
    case TonTransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TonWithdrawalStatus {
  TON_WITHDRAWAL_STATUS_UNSPECIFIED = 0,
  TON_WITHDRAWAL_STATUS_PENDING = 1,
  TON_WITHDRAWAL_STATUS_PAYMENT = 2,
  TON_WITHDRAWAL_STATUS_COMPLETED = 3,
  TON_WITHDRAWAL_STATUS_FAILED = 4,
  TON_WITHDRAWAL_STATUS_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function tonWithdrawalStatusFromJSON(object: any): TonWithdrawalStatus {
  switch (object) {
    case 0:
    case "TON_WITHDRAWAL_STATUS_UNSPECIFIED":
      return TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_UNSPECIFIED;
    case 1:
    case "TON_WITHDRAWAL_STATUS_PENDING":
      return TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_PENDING;
    case 2:
    case "TON_WITHDRAWAL_STATUS_PAYMENT":
      return TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_PAYMENT;
    case 3:
    case "TON_WITHDRAWAL_STATUS_COMPLETED":
      return TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_COMPLETED;
    case 4:
    case "TON_WITHDRAWAL_STATUS_FAILED":
      return TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_FAILED;
    case 5:
    case "TON_WITHDRAWAL_STATUS_CANCELLED":
      return TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TonWithdrawalStatus.UNRECOGNIZED;
  }
}

export function tonWithdrawalStatusToJSON(object: TonWithdrawalStatus): string {
  switch (object) {
    case TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_UNSPECIFIED:
      return "TON_WITHDRAWAL_STATUS_UNSPECIFIED";
    case TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_PENDING:
      return "TON_WITHDRAWAL_STATUS_PENDING";
    case TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_PAYMENT:
      return "TON_WITHDRAWAL_STATUS_PAYMENT";
    case TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_COMPLETED:
      return "TON_WITHDRAWAL_STATUS_COMPLETED";
    case TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_FAILED:
      return "TON_WITHDRAWAL_STATUS_FAILED";
    case TonWithdrawalStatus.TON_WITHDRAWAL_STATUS_CANCELLED:
      return "TON_WITHDRAWAL_STATUS_CANCELLED";
    case TonWithdrawalStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BalanceOperationType {
  BALANCE_OPERATION_TYPE_UNSPECIFIED = 0,
  /** BALANCE_OPERATION_TYPE_CREDIT - Add to balance */
  BALANCE_OPERATION_TYPE_CREDIT = 1,
  /** BALANCE_OPERATION_TYPE_DEBIT - Subtract from balance */
  BALANCE_OPERATION_TYPE_DEBIT = 2,
  /** BALANCE_OPERATION_TYPE_HOLD - Hold amount (for pending operations) */
  BALANCE_OPERATION_TYPE_HOLD = 3,
  /** BALANCE_OPERATION_TYPE_RELEASE - Release held amount */
  BALANCE_OPERATION_TYPE_RELEASE = 4,
  UNRECOGNIZED = -1,
}

export function balanceOperationTypeFromJSON(object: any): BalanceOperationType {
  switch (object) {
    case 0:
    case "BALANCE_OPERATION_TYPE_UNSPECIFIED":
      return BalanceOperationType.BALANCE_OPERATION_TYPE_UNSPECIFIED;
    case 1:
    case "BALANCE_OPERATION_TYPE_CREDIT":
      return BalanceOperationType.BALANCE_OPERATION_TYPE_CREDIT;
    case 2:
    case "BALANCE_OPERATION_TYPE_DEBIT":
      return BalanceOperationType.BALANCE_OPERATION_TYPE_DEBIT;
    case 3:
    case "BALANCE_OPERATION_TYPE_HOLD":
      return BalanceOperationType.BALANCE_OPERATION_TYPE_HOLD;
    case 4:
    case "BALANCE_OPERATION_TYPE_RELEASE":
      return BalanceOperationType.BALANCE_OPERATION_TYPE_RELEASE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BalanceOperationType.UNRECOGNIZED;
  }
}

export function balanceOperationTypeToJSON(object: BalanceOperationType): string {
  switch (object) {
    case BalanceOperationType.BALANCE_OPERATION_TYPE_UNSPECIFIED:
      return "BALANCE_OPERATION_TYPE_UNSPECIFIED";
    case BalanceOperationType.BALANCE_OPERATION_TYPE_CREDIT:
      return "BALANCE_OPERATION_TYPE_CREDIT";
    case BalanceOperationType.BALANCE_OPERATION_TYPE_DEBIT:
      return "BALANCE_OPERATION_TYPE_DEBIT";
    case BalanceOperationType.BALANCE_OPERATION_TYPE_HOLD:
      return "BALANCE_OPERATION_TYPE_HOLD";
    case BalanceOperationType.BALANCE_OPERATION_TYPE_RELEASE:
      return "BALANCE_OPERATION_TYPE_RELEASE";
    case BalanceOperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** data of invoice for stars deposit */
export interface StarsDeposit {
  $type: "giftduels.payment.v1.StarsDeposit";
  starsAmount:
    | StarsAmount
    | undefined;
  /** if needed */
  description: string;
}

/** data of invoice for gift withdrawal commission paid with stars */
export interface CommissionChargeStars {
  $type: "giftduels.payment.v1.CommissionChargeStars";
  giftId: GiftId | undefined;
  starsAmount: StarsAmount | undefined;
}

/** data for gift withdrawal commission paid with TON (no invoice, direct blockchain payment) */
export interface CommissionChargeTon {
  $type: "giftduels.payment.v1.CommissionChargeTon";
  giftId: GiftId | undefined;
  tonAmount:
    | TonAmount
    | undefined;
  /** comment for TON transaction identification */
  tonComment: string;
}

export interface StarTransaction {
  $type: "giftduels.payment.v1.StarTransaction";
  /** Transaction UUID */
  id: string;
  telegramUserId: TelegramUserId | undefined;
  invoiceId: string;
  starsAmount: StarsAmount | undefined;
  type: StarTransactionType;
  source: StarTransactionSource;
  purpose: StarTransactionPurpose;
  /** JSON metadata */
  metadata: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface TonTransaction {
  $type: "giftduels.payment.v1.TonTransaction";
  /** Transaction UUID */
  id: string;
  telegramUserId:
    | TelegramUserId
    | undefined;
  /** TON blockchain transaction hash */
  txHash: string;
  tonAmount: TonAmount | undefined;
  type: TonTransactionType;
  purpose: TonTransactionPurpose;
  /** JSON metadata */
  metadata: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  status: TonTransactionStatus;
}

export interface TonWithdrawal {
  $type: "giftduels.payment.v1.TonWithdrawal";
  /** Withdrawal tracking UUID */
  withdrawalId: string;
  recipientWalletAddress: string;
  tonAmount: TonAmount | undefined;
  comment: string;
  status: TonWithdrawalStatus;
  createdAt: Date | undefined;
  updatedAt:
    | Date
    | undefined;
  /** Set when transaction is confirmed */
  txHash: string;
  feeAmount: TonAmount | undefined;
}

export interface UserBalance {
  $type: "giftduels.payment.v1.UserBalance";
  telegramUserId: TelegramUserId | undefined;
  starsAmount: StarsAmount | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface BalanceOperation {
  $type: "giftduels.payment.v1.BalanceOperation";
  operationId: string;
  telegramUserId: TelegramUserId | undefined;
  type: BalanceOperationType;
  starsAmount: StarsAmount | undefined;
  description: string;
  /** Reference to related entity (gift_id, duel_id, etc.) */
  referenceId: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

function createBaseStarsDeposit(): StarsDeposit {
  return { $type: "giftduels.payment.v1.StarsDeposit", starsAmount: undefined, description: "" };
}

export const StarsDeposit: MessageFns<StarsDeposit, "giftduels.payment.v1.StarsDeposit"> = {
  $type: "giftduels.payment.v1.StarsDeposit" as const,

  encode(message: StarsDeposit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(10).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StarsDeposit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarsDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarsDeposit {
    return {
      $type: StarsDeposit.$type,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: StarsDeposit): unknown {
    const obj: any = {};
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarsDeposit>, I>>(base?: I): StarsDeposit {
    return StarsDeposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarsDeposit>, I>>(object: I): StarsDeposit {
    const message = createBaseStarsDeposit();
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCommissionChargeStars(): CommissionChargeStars {
  return { $type: "giftduels.payment.v1.CommissionChargeStars", giftId: undefined, starsAmount: undefined };
}

export const CommissionChargeStars: MessageFns<CommissionChargeStars, "giftduels.payment.v1.CommissionChargeStars"> = {
  $type: "giftduels.payment.v1.CommissionChargeStars" as const,

  encode(message: CommissionChargeStars, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommissionChargeStars {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommissionChargeStars();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommissionChargeStars {
    return {
      $type: CommissionChargeStars.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
    };
  },

  toJSON(message: CommissionChargeStars): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommissionChargeStars>, I>>(base?: I): CommissionChargeStars {
    return CommissionChargeStars.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommissionChargeStars>, I>>(object: I): CommissionChargeStars {
    const message = createBaseCommissionChargeStars();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    return message;
  },
};

function createBaseCommissionChargeTon(): CommissionChargeTon {
  return { $type: "giftduels.payment.v1.CommissionChargeTon", giftId: undefined, tonAmount: undefined, tonComment: "" };
}

export const CommissionChargeTon: MessageFns<CommissionChargeTon, "giftduels.payment.v1.CommissionChargeTon"> = {
  $type: "giftduels.payment.v1.CommissionChargeTon" as const,

  encode(message: CommissionChargeTon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.tonAmount !== undefined) {
      TonAmount.encode(message.tonAmount, writer.uint32(18).fork()).join();
    }
    if (message.tonComment !== "") {
      writer.uint32(26).string(message.tonComment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommissionChargeTon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommissionChargeTon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tonAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tonComment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommissionChargeTon {
    return {
      $type: CommissionChargeTon.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      tonAmount: isSet(object.tonAmount) ? TonAmount.fromJSON(object.tonAmount) : undefined,
      tonComment: isSet(object.tonComment) ? globalThis.String(object.tonComment) : "",
    };
  },

  toJSON(message: CommissionChargeTon): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.tonAmount !== undefined) {
      obj.tonAmount = TonAmount.toJSON(message.tonAmount);
    }
    if (message.tonComment !== "") {
      obj.tonComment = message.tonComment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommissionChargeTon>, I>>(base?: I): CommissionChargeTon {
    return CommissionChargeTon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommissionChargeTon>, I>>(object: I): CommissionChargeTon {
    const message = createBaseCommissionChargeTon();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.tonAmount = (object.tonAmount !== undefined && object.tonAmount !== null)
      ? TonAmount.fromPartial(object.tonAmount)
      : undefined;
    message.tonComment = object.tonComment ?? "";
    return message;
  },
};

function createBaseStarTransaction(): StarTransaction {
  return {
    $type: "giftduels.payment.v1.StarTransaction",
    id: "",
    telegramUserId: undefined,
    invoiceId: "",
    starsAmount: undefined,
    type: 0,
    source: 0,
    purpose: 0,
    metadata: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const StarTransaction: MessageFns<StarTransaction, "giftduels.payment.v1.StarTransaction"> = {
  $type: "giftduels.payment.v1.StarTransaction" as const,

  encode(message: StarTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.telegramUserId !== undefined) {
      TelegramUserId.encode(message.telegramUserId, writer.uint32(18).fork()).join();
    }
    if (message.invoiceId !== "") {
      writer.uint32(26).string(message.invoiceId);
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(34).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.source !== 0) {
      writer.uint32(48).int32(message.source);
    }
    if (message.purpose !== 0) {
      writer.uint32(56).int32(message.purpose);
    }
    if (message.metadata !== "") {
      writer.uint32(66).string(message.metadata);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StarTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.purpose = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarTransaction {
    return {
      $type: StarTransaction.$type,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      telegramUserId: isSet(object.telegramUserId) ? TelegramUserId.fromJSON(object.telegramUserId) : undefined,
      invoiceId: isSet(object.invoiceId) ? globalThis.String(object.invoiceId) : "",
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
      type: isSet(object.type) ? starTransactionTypeFromJSON(object.type) : 0,
      source: isSet(object.source) ? starTransactionSourceFromJSON(object.source) : 0,
      purpose: isSet(object.purpose) ? starTransactionPurposeFromJSON(object.purpose) : 0,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: StarTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.telegramUserId !== undefined) {
      obj.telegramUserId = TelegramUserId.toJSON(message.telegramUserId);
    }
    if (message.invoiceId !== "") {
      obj.invoiceId = message.invoiceId;
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    if (message.type !== 0) {
      obj.type = starTransactionTypeToJSON(message.type);
    }
    if (message.source !== 0) {
      obj.source = starTransactionSourceToJSON(message.source);
    }
    if (message.purpose !== 0) {
      obj.purpose = starTransactionPurposeToJSON(message.purpose);
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarTransaction>, I>>(base?: I): StarTransaction {
    return StarTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarTransaction>, I>>(object: I): StarTransaction {
    const message = createBaseStarTransaction();
    message.id = object.id ?? "";
    message.telegramUserId = (object.telegramUserId !== undefined && object.telegramUserId !== null)
      ? TelegramUserId.fromPartial(object.telegramUserId)
      : undefined;
    message.invoiceId = object.invoiceId ?? "";
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    message.type = object.type ?? 0;
    message.source = object.source ?? 0;
    message.purpose = object.purpose ?? 0;
    message.metadata = object.metadata ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseTonTransaction(): TonTransaction {
  return {
    $type: "giftduels.payment.v1.TonTransaction",
    id: "",
    telegramUserId: undefined,
    txHash: "",
    tonAmount: undefined,
    type: 0,
    purpose: 0,
    metadata: "",
    createdAt: undefined,
    updatedAt: undefined,
    status: 0,
  };
}

export const TonTransaction: MessageFns<TonTransaction, "giftduels.payment.v1.TonTransaction"> = {
  $type: "giftduels.payment.v1.TonTransaction" as const,

  encode(message: TonTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.telegramUserId !== undefined) {
      TelegramUserId.encode(message.telegramUserId, writer.uint32(18).fork()).join();
    }
    if (message.txHash !== "") {
      writer.uint32(26).string(message.txHash);
    }
    if (message.tonAmount !== undefined) {
      TonAmount.encode(message.tonAmount, writer.uint32(34).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.purpose !== 0) {
      writer.uint32(48).int32(message.purpose);
    }
    if (message.metadata !== "") {
      writer.uint32(58).string(message.metadata);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TonTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTonTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tonAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.purpose = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TonTransaction {
    return {
      $type: TonTransaction.$type,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      telegramUserId: isSet(object.telegramUserId) ? TelegramUserId.fromJSON(object.telegramUserId) : undefined,
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      tonAmount: isSet(object.tonAmount) ? TonAmount.fromJSON(object.tonAmount) : undefined,
      type: isSet(object.type) ? tonTransactionTypeFromJSON(object.type) : 0,
      purpose: isSet(object.purpose) ? tonTransactionPurposeFromJSON(object.purpose) : 0,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      status: isSet(object.status) ? tonTransactionStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: TonTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.telegramUserId !== undefined) {
      obj.telegramUserId = TelegramUserId.toJSON(message.telegramUserId);
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.tonAmount !== undefined) {
      obj.tonAmount = TonAmount.toJSON(message.tonAmount);
    }
    if (message.type !== 0) {
      obj.type = tonTransactionTypeToJSON(message.type);
    }
    if (message.purpose !== 0) {
      obj.purpose = tonTransactionPurposeToJSON(message.purpose);
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = tonTransactionStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TonTransaction>, I>>(base?: I): TonTransaction {
    return TonTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TonTransaction>, I>>(object: I): TonTransaction {
    const message = createBaseTonTransaction();
    message.id = object.id ?? "";
    message.telegramUserId = (object.telegramUserId !== undefined && object.telegramUserId !== null)
      ? TelegramUserId.fromPartial(object.telegramUserId)
      : undefined;
    message.txHash = object.txHash ?? "";
    message.tonAmount = (object.tonAmount !== undefined && object.tonAmount !== null)
      ? TonAmount.fromPartial(object.tonAmount)
      : undefined;
    message.type = object.type ?? 0;
    message.purpose = object.purpose ?? 0;
    message.metadata = object.metadata ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTonWithdrawal(): TonWithdrawal {
  return {
    $type: "giftduels.payment.v1.TonWithdrawal",
    withdrawalId: "",
    recipientWalletAddress: "",
    tonAmount: undefined,
    comment: "",
    status: 0,
    createdAt: undefined,
    updatedAt: undefined,
    txHash: "",
    feeAmount: undefined,
  };
}

export const TonWithdrawal: MessageFns<TonWithdrawal, "giftduels.payment.v1.TonWithdrawal"> = {
  $type: "giftduels.payment.v1.TonWithdrawal" as const,

  encode(message: TonWithdrawal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.withdrawalId !== "") {
      writer.uint32(10).string(message.withdrawalId);
    }
    if (message.recipientWalletAddress !== "") {
      writer.uint32(18).string(message.recipientWalletAddress);
    }
    if (message.tonAmount !== undefined) {
      TonAmount.encode(message.tonAmount, writer.uint32(26).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    if (message.txHash !== "") {
      writer.uint32(66).string(message.txHash);
    }
    if (message.feeAmount !== undefined) {
      TonAmount.encode(message.feeAmount, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TonWithdrawal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTonWithdrawal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.withdrawalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipientWalletAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tonAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.feeAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TonWithdrawal {
    return {
      $type: TonWithdrawal.$type,
      withdrawalId: isSet(object.withdrawalId) ? globalThis.String(object.withdrawalId) : "",
      recipientWalletAddress: isSet(object.recipientWalletAddress)
        ? globalThis.String(object.recipientWalletAddress)
        : "",
      tonAmount: isSet(object.tonAmount) ? TonAmount.fromJSON(object.tonAmount) : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      status: isSet(object.status) ? tonWithdrawalStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      feeAmount: isSet(object.feeAmount) ? TonAmount.fromJSON(object.feeAmount) : undefined,
    };
  },

  toJSON(message: TonWithdrawal): unknown {
    const obj: any = {};
    if (message.withdrawalId !== "") {
      obj.withdrawalId = message.withdrawalId;
    }
    if (message.recipientWalletAddress !== "") {
      obj.recipientWalletAddress = message.recipientWalletAddress;
    }
    if (message.tonAmount !== undefined) {
      obj.tonAmount = TonAmount.toJSON(message.tonAmount);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.status !== 0) {
      obj.status = tonWithdrawalStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.feeAmount !== undefined) {
      obj.feeAmount = TonAmount.toJSON(message.feeAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TonWithdrawal>, I>>(base?: I): TonWithdrawal {
    return TonWithdrawal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TonWithdrawal>, I>>(object: I): TonWithdrawal {
    const message = createBaseTonWithdrawal();
    message.withdrawalId = object.withdrawalId ?? "";
    message.recipientWalletAddress = object.recipientWalletAddress ?? "";
    message.tonAmount = (object.tonAmount !== undefined && object.tonAmount !== null)
      ? TonAmount.fromPartial(object.tonAmount)
      : undefined;
    message.comment = object.comment ?? "";
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.txHash = object.txHash ?? "";
    message.feeAmount = (object.feeAmount !== undefined && object.feeAmount !== null)
      ? TonAmount.fromPartial(object.feeAmount)
      : undefined;
    return message;
  },
};

function createBaseUserBalance(): UserBalance {
  return {
    $type: "giftduels.payment.v1.UserBalance",
    telegramUserId: undefined,
    starsAmount: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const UserBalance: MessageFns<UserBalance, "giftduels.payment.v1.UserBalance"> = {
  $type: "giftduels.payment.v1.UserBalance" as const,

  encode(message: UserBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.telegramUserId !== undefined) {
      TelegramUserId.encode(message.telegramUserId, writer.uint32(10).fork()).join();
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.telegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBalance {
    return {
      $type: UserBalance.$type,
      telegramUserId: isSet(object.telegramUserId) ? TelegramUserId.fromJSON(object.telegramUserId) : undefined,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: UserBalance): unknown {
    const obj: any = {};
    if (message.telegramUserId !== undefined) {
      obj.telegramUserId = TelegramUserId.toJSON(message.telegramUserId);
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserBalance>, I>>(base?: I): UserBalance {
    return UserBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserBalance>, I>>(object: I): UserBalance {
    const message = createBaseUserBalance();
    message.telegramUserId = (object.telegramUserId !== undefined && object.telegramUserId !== null)
      ? TelegramUserId.fromPartial(object.telegramUserId)
      : undefined;
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseBalanceOperation(): BalanceOperation {
  return {
    $type: "giftduels.payment.v1.BalanceOperation",
    operationId: "",
    telegramUserId: undefined,
    type: 0,
    starsAmount: undefined,
    description: "",
    referenceId: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const BalanceOperation: MessageFns<BalanceOperation, "giftduels.payment.v1.BalanceOperation"> = {
  $type: "giftduels.payment.v1.BalanceOperation" as const,

  encode(message: BalanceOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationId !== "") {
      writer.uint32(10).string(message.operationId);
    }
    if (message.telegramUserId !== undefined) {
      TelegramUserId.encode(message.telegramUserId, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.referenceId !== "") {
      writer.uint32(50).string(message.referenceId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegramUserId = TelegramUserId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceOperation {
    return {
      $type: BalanceOperation.$type,
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      telegramUserId: isSet(object.telegramUserId) ? TelegramUserId.fromJSON(object.telegramUserId) : undefined,
      type: isSet(object.type) ? balanceOperationTypeFromJSON(object.type) : 0,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: BalanceOperation): unknown {
    const obj: any = {};
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.telegramUserId !== undefined) {
      obj.telegramUserId = TelegramUserId.toJSON(message.telegramUserId);
    }
    if (message.type !== 0) {
      obj.type = balanceOperationTypeToJSON(message.type);
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceOperation>, I>>(base?: I): BalanceOperation {
    return BalanceOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceOperation>, I>>(object: I): BalanceOperation {
    const message = createBaseBalanceOperation();
    message.operationId = object.operationId ?? "";
    message.telegramUserId = (object.telegramUserId !== undefined && object.telegramUserId !== null)
      ? TelegramUserId.fromPartial(object.telegramUserId)
      : undefined;
    message.type = object.type ?? 0;
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    message.description = object.description ?? "";
    message.referenceId = object.referenceId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
