// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/payment/v1/public_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  GiftId,
  NumericRangeFilter,
  PageRequest,
  PageResponse,
  SortOrder,
  sortOrderFromJSON,
  sortOrderToJSON,
  StarsAmount,
  TimeRangeFilter,
  TonAmount,
} from "../../shared/v1/common";
import {
  StarTransaction,
  StarTransactionPurpose,
  starTransactionPurposeFromJSON,
  starTransactionPurposeToJSON,
  StarTransactionType,
  starTransactionTypeFromJSON,
  starTransactionTypeToJSON,
  TonTransaction,
  TonTransactionPurpose,
  tonTransactionPurposeFromJSON,
  tonTransactionPurposeToJSON,
  TonTransactionType,
  tonTransactionTypeFromJSON,
  tonTransactionTypeToJSON,
  TonWithdrawal,
  UserBalance,
} from "./payment";

export enum TransactionSortField {
  TRANSACTION_SORT_FIELD_UNSPECIFIED = 0,
  TRANSACTION_SORT_FIELD_CREATED_AT = 1,
  TRANSACTION_SORT_FIELD_AMOUNT = 2,
  TRANSACTION_SORT_FIELD_TYPE = 3,
  UNRECOGNIZED = -1,
}

export function transactionSortFieldFromJSON(object: any): TransactionSortField {
  switch (object) {
    case 0:
    case "TRANSACTION_SORT_FIELD_UNSPECIFIED":
      return TransactionSortField.TRANSACTION_SORT_FIELD_UNSPECIFIED;
    case 1:
    case "TRANSACTION_SORT_FIELD_CREATED_AT":
      return TransactionSortField.TRANSACTION_SORT_FIELD_CREATED_AT;
    case 2:
    case "TRANSACTION_SORT_FIELD_AMOUNT":
      return TransactionSortField.TRANSACTION_SORT_FIELD_AMOUNT;
    case 3:
    case "TRANSACTION_SORT_FIELD_TYPE":
      return TransactionSortField.TRANSACTION_SORT_FIELD_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionSortField.UNRECOGNIZED;
  }
}

export function transactionSortFieldToJSON(object: TransactionSortField): string {
  switch (object) {
    case TransactionSortField.TRANSACTION_SORT_FIELD_UNSPECIFIED:
      return "TRANSACTION_SORT_FIELD_UNSPECIFIED";
    case TransactionSortField.TRANSACTION_SORT_FIELD_CREATED_AT:
      return "TRANSACTION_SORT_FIELD_CREATED_AT";
    case TransactionSortField.TRANSACTION_SORT_FIELD_AMOUNT:
      return "TRANSACTION_SORT_FIELD_AMOUNT";
    case TransactionSortField.TRANSACTION_SORT_FIELD_TYPE:
      return "TRANSACTION_SORT_FIELD_TYPE";
    case TransactionSortField.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateWithdrawCommissionReceiptRequest {
  $type: "giftduels.payment.v1.CreateWithdrawCommissionReceiptRequest";
  giftId: GiftId | undefined;
}

export interface CreateWithdrawCommissionReceiptResponse {
  $type: "giftduels.payment.v1.CreateWithdrawCommissionReceiptResponse";
  tonComment?: string | undefined;
  invoiceUrl?: string | undefined;
  tonAmount: TonAmount | undefined;
  starsAmount: StarsAmount | undefined;
}

export interface DepositStarsRequest {
  $type: "giftduels.payment.v1.DepositStarsRequest";
  starsAmount: StarsAmount | undefined;
  description: string;
}

export interface DepositStarsResponse {
  $type: "giftduels.payment.v1.DepositStarsResponse";
  invoiceUrl: string;
  starsAmount: StarsAmount | undefined;
}

export interface GetBalanceResponse {
  $type: "giftduels.payment.v1.GetBalanceResponse";
  balance: UserBalance | undefined;
}

export interface CalculateWithdrawCommissionRequest {
  $type: "giftduels.payment.v1.CalculateWithdrawCommissionRequest";
  giftId: GiftId | undefined;
}

export interface CalculateWithdrawCommissionResponse {
  $type: "giftduels.payment.v1.CalculateWithdrawCommissionResponse";
  tonAmount: TonAmount | undefined;
  starsAmount: StarsAmount | undefined;
}

export interface GetTransactionHistoryRequest {
  $type: "giftduels.payment.v1.GetTransactionHistoryRequest";
  filters: TransactionFilters | undefined;
  sort: TransactionSortOptions | undefined;
  pagination: PageRequest | undefined;
}

export interface GetTransactionHistoryResponse {
  $type: "giftduels.payment.v1.GetTransactionHistoryResponse";
  transactions: TransactionSummary[];
  pagination: PageResponse | undefined;
  stats: TransactionStats | undefined;
}

export interface TransactionFilters {
  $type: "giftduels.payment.v1.TransactionFilters";
  starTypes: StarTransactionType[];
  tonTypes: TonTransactionType[];
  starPurposes: StarTransactionPurpose[];
  tonPurposes: TonTransactionPurpose[];
  timeRange:
    | TimeRangeFilter
    | undefined;
  /** In smallest units */
  amountRange: NumericRangeFilter | undefined;
}

export interface TransactionSortOptions {
  $type: "giftduels.payment.v1.TransactionSortOptions";
  field: TransactionSortField;
  order: SortOrder;
}

export interface TransactionSummary {
  $type: "giftduels.payment.v1.TransactionSummary";
  id: string;
  starTransaction?: StarTransaction | undefined;
  tonTransaction?: TonTransaction | undefined;
  description: string;
}

export interface TransactionStats {
  $type: "giftduels.payment.v1.TransactionStats";
  totalCount: number;
  totalStarsIn: StarsAmount | undefined;
  totalStarsOut: StarsAmount | undefined;
  totalTonIn: TonAmount | undefined;
  totalTonOut: TonAmount | undefined;
}

export interface GetWithdrawalStatusRequest {
  $type: "giftduels.payment.v1.GetWithdrawalStatusRequest";
  withdrawalId: string;
}

export interface GetWithdrawalStatusResponse {
  $type: "giftduels.payment.v1.GetWithdrawalStatusResponse";
  withdrawal: TonWithdrawal | undefined;
}

function createBaseCreateWithdrawCommissionReceiptRequest(): CreateWithdrawCommissionReceiptRequest {
  return { $type: "giftduels.payment.v1.CreateWithdrawCommissionReceiptRequest", giftId: undefined };
}

export const CreateWithdrawCommissionReceiptRequest: MessageFns<
  CreateWithdrawCommissionReceiptRequest,
  "giftduels.payment.v1.CreateWithdrawCommissionReceiptRequest"
> = {
  $type: "giftduels.payment.v1.CreateWithdrawCommissionReceiptRequest" as const,

  encode(message: CreateWithdrawCommissionReceiptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWithdrawCommissionReceiptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWithdrawCommissionReceiptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWithdrawCommissionReceiptRequest {
    return {
      $type: CreateWithdrawCommissionReceiptRequest.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
    };
  },

  toJSON(message: CreateWithdrawCommissionReceiptRequest): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateWithdrawCommissionReceiptRequest>, I>>(
    base?: I,
  ): CreateWithdrawCommissionReceiptRequest {
    return CreateWithdrawCommissionReceiptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateWithdrawCommissionReceiptRequest>, I>>(
    object: I,
  ): CreateWithdrawCommissionReceiptRequest {
    const message = createBaseCreateWithdrawCommissionReceiptRequest();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    return message;
  },
};

function createBaseCreateWithdrawCommissionReceiptResponse(): CreateWithdrawCommissionReceiptResponse {
  return {
    $type: "giftduels.payment.v1.CreateWithdrawCommissionReceiptResponse",
    tonComment: undefined,
    invoiceUrl: undefined,
    tonAmount: undefined,
    starsAmount: undefined,
  };
}

export const CreateWithdrawCommissionReceiptResponse: MessageFns<
  CreateWithdrawCommissionReceiptResponse,
  "giftduels.payment.v1.CreateWithdrawCommissionReceiptResponse"
> = {
  $type: "giftduels.payment.v1.CreateWithdrawCommissionReceiptResponse" as const,

  encode(message: CreateWithdrawCommissionReceiptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tonComment !== undefined) {
      writer.uint32(10).string(message.tonComment);
    }
    if (message.invoiceUrl !== undefined) {
      writer.uint32(18).string(message.invoiceUrl);
    }
    if (message.tonAmount !== undefined) {
      TonAmount.encode(message.tonAmount, writer.uint32(26).fork()).join();
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWithdrawCommissionReceiptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWithdrawCommissionReceiptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tonComment = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tonAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWithdrawCommissionReceiptResponse {
    return {
      $type: CreateWithdrawCommissionReceiptResponse.$type,
      tonComment: isSet(object.tonComment) ? globalThis.String(object.tonComment) : undefined,
      invoiceUrl: isSet(object.invoiceUrl) ? globalThis.String(object.invoiceUrl) : undefined,
      tonAmount: isSet(object.tonAmount) ? TonAmount.fromJSON(object.tonAmount) : undefined,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
    };
  },

  toJSON(message: CreateWithdrawCommissionReceiptResponse): unknown {
    const obj: any = {};
    if (message.tonComment !== undefined) {
      obj.tonComment = message.tonComment;
    }
    if (message.invoiceUrl !== undefined) {
      obj.invoiceUrl = message.invoiceUrl;
    }
    if (message.tonAmount !== undefined) {
      obj.tonAmount = TonAmount.toJSON(message.tonAmount);
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateWithdrawCommissionReceiptResponse>, I>>(
    base?: I,
  ): CreateWithdrawCommissionReceiptResponse {
    return CreateWithdrawCommissionReceiptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateWithdrawCommissionReceiptResponse>, I>>(
    object: I,
  ): CreateWithdrawCommissionReceiptResponse {
    const message = createBaseCreateWithdrawCommissionReceiptResponse();
    message.tonComment = object.tonComment ?? undefined;
    message.invoiceUrl = object.invoiceUrl ?? undefined;
    message.tonAmount = (object.tonAmount !== undefined && object.tonAmount !== null)
      ? TonAmount.fromPartial(object.tonAmount)
      : undefined;
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    return message;
  },
};

function createBaseDepositStarsRequest(): DepositStarsRequest {
  return { $type: "giftduels.payment.v1.DepositStarsRequest", starsAmount: undefined, description: "" };
}

export const DepositStarsRequest: MessageFns<DepositStarsRequest, "giftduels.payment.v1.DepositStarsRequest"> = {
  $type: "giftduels.payment.v1.DepositStarsRequest" as const,

  encode(message: DepositStarsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(10).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositStarsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositStarsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositStarsRequest {
    return {
      $type: DepositStarsRequest.$type,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: DepositStarsRequest): unknown {
    const obj: any = {};
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositStarsRequest>, I>>(base?: I): DepositStarsRequest {
    return DepositStarsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositStarsRequest>, I>>(object: I): DepositStarsRequest {
    const message = createBaseDepositStarsRequest();
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseDepositStarsResponse(): DepositStarsResponse {
  return { $type: "giftduels.payment.v1.DepositStarsResponse", invoiceUrl: "", starsAmount: undefined };
}

export const DepositStarsResponse: MessageFns<DepositStarsResponse, "giftduels.payment.v1.DepositStarsResponse"> = {
  $type: "giftduels.payment.v1.DepositStarsResponse" as const,

  encode(message: DepositStarsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoiceUrl !== "") {
      writer.uint32(10).string(message.invoiceUrl);
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositStarsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositStarsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invoiceUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositStarsResponse {
    return {
      $type: DepositStarsResponse.$type,
      invoiceUrl: isSet(object.invoiceUrl) ? globalThis.String(object.invoiceUrl) : "",
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
    };
  },

  toJSON(message: DepositStarsResponse): unknown {
    const obj: any = {};
    if (message.invoiceUrl !== "") {
      obj.invoiceUrl = message.invoiceUrl;
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositStarsResponse>, I>>(base?: I): DepositStarsResponse {
    return DepositStarsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositStarsResponse>, I>>(object: I): DepositStarsResponse {
    const message = createBaseDepositStarsResponse();
    message.invoiceUrl = object.invoiceUrl ?? "";
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    return message;
  },
};

function createBaseGetBalanceResponse(): GetBalanceResponse {
  return { $type: "giftduels.payment.v1.GetBalanceResponse", balance: undefined };
}

export const GetBalanceResponse: MessageFns<GetBalanceResponse, "giftduels.payment.v1.GetBalanceResponse"> = {
  $type: "giftduels.payment.v1.GetBalanceResponse" as const,

  encode(message: GetBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== undefined) {
      UserBalance.encode(message.balance, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = UserBalance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceResponse {
    return {
      $type: GetBalanceResponse.$type,
      balance: isSet(object.balance) ? UserBalance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: GetBalanceResponse): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = UserBalance.toJSON(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(base?: I): GetBalanceResponse {
    return GetBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(object: I): GetBalanceResponse {
    const message = createBaseGetBalanceResponse();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? UserBalance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseCalculateWithdrawCommissionRequest(): CalculateWithdrawCommissionRequest {
  return { $type: "giftduels.payment.v1.CalculateWithdrawCommissionRequest", giftId: undefined };
}

export const CalculateWithdrawCommissionRequest: MessageFns<
  CalculateWithdrawCommissionRequest,
  "giftduels.payment.v1.CalculateWithdrawCommissionRequest"
> = {
  $type: "giftduels.payment.v1.CalculateWithdrawCommissionRequest" as const,

  encode(message: CalculateWithdrawCommissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateWithdrawCommissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateWithdrawCommissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculateWithdrawCommissionRequest {
    return {
      $type: CalculateWithdrawCommissionRequest.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
    };
  },

  toJSON(message: CalculateWithdrawCommissionRequest): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalculateWithdrawCommissionRequest>, I>>(
    base?: I,
  ): CalculateWithdrawCommissionRequest {
    return CalculateWithdrawCommissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalculateWithdrawCommissionRequest>, I>>(
    object: I,
  ): CalculateWithdrawCommissionRequest {
    const message = createBaseCalculateWithdrawCommissionRequest();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    return message;
  },
};

function createBaseCalculateWithdrawCommissionResponse(): CalculateWithdrawCommissionResponse {
  return {
    $type: "giftduels.payment.v1.CalculateWithdrawCommissionResponse",
    tonAmount: undefined,
    starsAmount: undefined,
  };
}

export const CalculateWithdrawCommissionResponse: MessageFns<
  CalculateWithdrawCommissionResponse,
  "giftduels.payment.v1.CalculateWithdrawCommissionResponse"
> = {
  $type: "giftduels.payment.v1.CalculateWithdrawCommissionResponse" as const,

  encode(message: CalculateWithdrawCommissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tonAmount !== undefined) {
      TonAmount.encode(message.tonAmount, writer.uint32(10).fork()).join();
    }
    if (message.starsAmount !== undefined) {
      StarsAmount.encode(message.starsAmount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateWithdrawCommissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateWithdrawCommissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tonAmount = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starsAmount = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculateWithdrawCommissionResponse {
    return {
      $type: CalculateWithdrawCommissionResponse.$type,
      tonAmount: isSet(object.tonAmount) ? TonAmount.fromJSON(object.tonAmount) : undefined,
      starsAmount: isSet(object.starsAmount) ? StarsAmount.fromJSON(object.starsAmount) : undefined,
    };
  },

  toJSON(message: CalculateWithdrawCommissionResponse): unknown {
    const obj: any = {};
    if (message.tonAmount !== undefined) {
      obj.tonAmount = TonAmount.toJSON(message.tonAmount);
    }
    if (message.starsAmount !== undefined) {
      obj.starsAmount = StarsAmount.toJSON(message.starsAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalculateWithdrawCommissionResponse>, I>>(
    base?: I,
  ): CalculateWithdrawCommissionResponse {
    return CalculateWithdrawCommissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalculateWithdrawCommissionResponse>, I>>(
    object: I,
  ): CalculateWithdrawCommissionResponse {
    const message = createBaseCalculateWithdrawCommissionResponse();
    message.tonAmount = (object.tonAmount !== undefined && object.tonAmount !== null)
      ? TonAmount.fromPartial(object.tonAmount)
      : undefined;
    message.starsAmount = (object.starsAmount !== undefined && object.starsAmount !== null)
      ? StarsAmount.fromPartial(object.starsAmount)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionHistoryRequest(): GetTransactionHistoryRequest {
  return {
    $type: "giftduels.payment.v1.GetTransactionHistoryRequest",
    filters: undefined,
    sort: undefined,
    pagination: undefined,
  };
}

export const GetTransactionHistoryRequest: MessageFns<
  GetTransactionHistoryRequest,
  "giftduels.payment.v1.GetTransactionHistoryRequest"
> = {
  $type: "giftduels.payment.v1.GetTransactionHistoryRequest" as const,

  encode(message: GetTransactionHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      TransactionFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    if (message.sort !== undefined) {
      TransactionSortOptions.encode(message.sort, writer.uint32(18).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = TransactionFilters.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sort = TransactionSortOptions.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionHistoryRequest {
    return {
      $type: GetTransactionHistoryRequest.$type,
      filters: isSet(object.filters) ? TransactionFilters.fromJSON(object.filters) : undefined,
      sort: isSet(object.sort) ? TransactionSortOptions.fromJSON(object.sort) : undefined,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetTransactionHistoryRequest): unknown {
    const obj: any = {};
    if (message.filters !== undefined) {
      obj.filters = TransactionFilters.toJSON(message.filters);
    }
    if (message.sort !== undefined) {
      obj.sort = TransactionSortOptions.toJSON(message.sort);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionHistoryRequest>, I>>(base?: I): GetTransactionHistoryRequest {
    return GetTransactionHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionHistoryRequest>, I>>(object: I): GetTransactionHistoryRequest {
    const message = createBaseGetTransactionHistoryRequest();
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? TransactionFilters.fromPartial(object.filters)
      : undefined;
    message.sort = (object.sort !== undefined && object.sort !== null)
      ? TransactionSortOptions.fromPartial(object.sort)
      : undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionHistoryResponse(): GetTransactionHistoryResponse {
  return {
    $type: "giftduels.payment.v1.GetTransactionHistoryResponse",
    transactions: [],
    pagination: undefined,
    stats: undefined,
  };
}

export const GetTransactionHistoryResponse: MessageFns<
  GetTransactionHistoryResponse,
  "giftduels.payment.v1.GetTransactionHistoryResponse"
> = {
  $type: "giftduels.payment.v1.GetTransactionHistoryResponse" as const,

  encode(message: GetTransactionHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      TransactionSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.stats !== undefined) {
      TransactionStats.encode(message.stats, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionSummary.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stats = TransactionStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionHistoryResponse {
    return {
      $type: GetTransactionHistoryResponse.$type,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionSummary.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      stats: isSet(object.stats) ? TransactionStats.fromJSON(object.stats) : undefined,
    };
  },

  toJSON(message: GetTransactionHistoryResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionSummary.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.stats !== undefined) {
      obj.stats = TransactionStats.toJSON(message.stats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionHistoryResponse>, I>>(base?: I): GetTransactionHistoryResponse {
    return GetTransactionHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionHistoryResponse>, I>>(
    object: I,
  ): GetTransactionHistoryResponse {
    const message = createBaseGetTransactionHistoryResponse();
    message.transactions = object.transactions?.map((e) => TransactionSummary.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? TransactionStats.fromPartial(object.stats)
      : undefined;
    return message;
  },
};

function createBaseTransactionFilters(): TransactionFilters {
  return {
    $type: "giftduels.payment.v1.TransactionFilters",
    starTypes: [],
    tonTypes: [],
    starPurposes: [],
    tonPurposes: [],
    timeRange: undefined,
    amountRange: undefined,
  };
}

export const TransactionFilters: MessageFns<TransactionFilters, "giftduels.payment.v1.TransactionFilters"> = {
  $type: "giftduels.payment.v1.TransactionFilters" as const,

  encode(message: TransactionFilters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.starTypes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.tonTypes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.starPurposes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.tonPurposes) {
      writer.int32(v);
    }
    writer.join();
    if (message.timeRange !== undefined) {
      TimeRangeFilter.encode(message.timeRange, writer.uint32(42).fork()).join();
    }
    if (message.amountRange !== undefined) {
      NumericRangeFilter.encode(message.amountRange, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionFilters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.starTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.starTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.tonTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tonTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.starPurposes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.starPurposes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.tonPurposes.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tonPurposes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timeRange = TimeRangeFilter.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amountRange = NumericRangeFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFilters {
    return {
      $type: TransactionFilters.$type,
      starTypes: globalThis.Array.isArray(object?.starTypes)
        ? object.starTypes.map((e: any) => starTransactionTypeFromJSON(e))
        : [],
      tonTypes: globalThis.Array.isArray(object?.tonTypes)
        ? object.tonTypes.map((e: any) => tonTransactionTypeFromJSON(e))
        : [],
      starPurposes: globalThis.Array.isArray(object?.starPurposes)
        ? object.starPurposes.map((e: any) => starTransactionPurposeFromJSON(e))
        : [],
      tonPurposes: globalThis.Array.isArray(object?.tonPurposes)
        ? object.tonPurposes.map((e: any) => tonTransactionPurposeFromJSON(e))
        : [],
      timeRange: isSet(object.timeRange) ? TimeRangeFilter.fromJSON(object.timeRange) : undefined,
      amountRange: isSet(object.amountRange) ? NumericRangeFilter.fromJSON(object.amountRange) : undefined,
    };
  },

  toJSON(message: TransactionFilters): unknown {
    const obj: any = {};
    if (message.starTypes?.length) {
      obj.starTypes = message.starTypes.map((e) => starTransactionTypeToJSON(e));
    }
    if (message.tonTypes?.length) {
      obj.tonTypes = message.tonTypes.map((e) => tonTransactionTypeToJSON(e));
    }
    if (message.starPurposes?.length) {
      obj.starPurposes = message.starPurposes.map((e) => starTransactionPurposeToJSON(e));
    }
    if (message.tonPurposes?.length) {
      obj.tonPurposes = message.tonPurposes.map((e) => tonTransactionPurposeToJSON(e));
    }
    if (message.timeRange !== undefined) {
      obj.timeRange = TimeRangeFilter.toJSON(message.timeRange);
    }
    if (message.amountRange !== undefined) {
      obj.amountRange = NumericRangeFilter.toJSON(message.amountRange);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionFilters>, I>>(base?: I): TransactionFilters {
    return TransactionFilters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionFilters>, I>>(object: I): TransactionFilters {
    const message = createBaseTransactionFilters();
    message.starTypes = object.starTypes?.map((e) => e) || [];
    message.tonTypes = object.tonTypes?.map((e) => e) || [];
    message.starPurposes = object.starPurposes?.map((e) => e) || [];
    message.tonPurposes = object.tonPurposes?.map((e) => e) || [];
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? TimeRangeFilter.fromPartial(object.timeRange)
      : undefined;
    message.amountRange = (object.amountRange !== undefined && object.amountRange !== null)
      ? NumericRangeFilter.fromPartial(object.amountRange)
      : undefined;
    return message;
  },
};

function createBaseTransactionSortOptions(): TransactionSortOptions {
  return { $type: "giftduels.payment.v1.TransactionSortOptions", field: 0, order: 0 };
}

export const TransactionSortOptions: MessageFns<TransactionSortOptions, "giftduels.payment.v1.TransactionSortOptions"> =
  {
    $type: "giftduels.payment.v1.TransactionSortOptions" as const,

    encode(message: TransactionSortOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.field !== 0) {
        writer.uint32(8).int32(message.field);
      }
      if (message.order !== 0) {
        writer.uint32(16).int32(message.order);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TransactionSortOptions {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTransactionSortOptions();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.field = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.order = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TransactionSortOptions {
      return {
        $type: TransactionSortOptions.$type,
        field: isSet(object.field) ? transactionSortFieldFromJSON(object.field) : 0,
        order: isSet(object.order) ? sortOrderFromJSON(object.order) : 0,
      };
    },

    toJSON(message: TransactionSortOptions): unknown {
      const obj: any = {};
      if (message.field !== 0) {
        obj.field = transactionSortFieldToJSON(message.field);
      }
      if (message.order !== 0) {
        obj.order = sortOrderToJSON(message.order);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TransactionSortOptions>, I>>(base?: I): TransactionSortOptions {
      return TransactionSortOptions.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TransactionSortOptions>, I>>(object: I): TransactionSortOptions {
      const message = createBaseTransactionSortOptions();
      message.field = object.field ?? 0;
      message.order = object.order ?? 0;
      return message;
    },
  };

function createBaseTransactionSummary(): TransactionSummary {
  return {
    $type: "giftduels.payment.v1.TransactionSummary",
    id: "",
    starTransaction: undefined,
    tonTransaction: undefined,
    description: "",
  };
}

export const TransactionSummary: MessageFns<TransactionSummary, "giftduels.payment.v1.TransactionSummary"> = {
  $type: "giftduels.payment.v1.TransactionSummary" as const,

  encode(message: TransactionSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.starTransaction !== undefined) {
      StarTransaction.encode(message.starTransaction, writer.uint32(18).fork()).join();
    }
    if (message.tonTransaction !== undefined) {
      TonTransaction.encode(message.tonTransaction, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.starTransaction = StarTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tonTransaction = TonTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionSummary {
    return {
      $type: TransactionSummary.$type,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      starTransaction: isSet(object.starTransaction) ? StarTransaction.fromJSON(object.starTransaction) : undefined,
      tonTransaction: isSet(object.tonTransaction) ? TonTransaction.fromJSON(object.tonTransaction) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: TransactionSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.starTransaction !== undefined) {
      obj.starTransaction = StarTransaction.toJSON(message.starTransaction);
    }
    if (message.tonTransaction !== undefined) {
      obj.tonTransaction = TonTransaction.toJSON(message.tonTransaction);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionSummary>, I>>(base?: I): TransactionSummary {
    return TransactionSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionSummary>, I>>(object: I): TransactionSummary {
    const message = createBaseTransactionSummary();
    message.id = object.id ?? "";
    message.starTransaction = (object.starTransaction !== undefined && object.starTransaction !== null)
      ? StarTransaction.fromPartial(object.starTransaction)
      : undefined;
    message.tonTransaction = (object.tonTransaction !== undefined && object.tonTransaction !== null)
      ? TonTransaction.fromPartial(object.tonTransaction)
      : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseTransactionStats(): TransactionStats {
  return {
    $type: "giftduels.payment.v1.TransactionStats",
    totalCount: 0,
    totalStarsIn: undefined,
    totalStarsOut: undefined,
    totalTonIn: undefined,
    totalTonOut: undefined,
  };
}

export const TransactionStats: MessageFns<TransactionStats, "giftduels.payment.v1.TransactionStats"> = {
  $type: "giftduels.payment.v1.TransactionStats" as const,

  encode(message: TransactionStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCount !== 0) {
      writer.uint32(8).uint32(message.totalCount);
    }
    if (message.totalStarsIn !== undefined) {
      StarsAmount.encode(message.totalStarsIn, writer.uint32(18).fork()).join();
    }
    if (message.totalStarsOut !== undefined) {
      StarsAmount.encode(message.totalStarsOut, writer.uint32(26).fork()).join();
    }
    if (message.totalTonIn !== undefined) {
      TonAmount.encode(message.totalTonIn, writer.uint32(34).fork()).join();
    }
    if (message.totalTonOut !== undefined) {
      TonAmount.encode(message.totalTonOut, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.totalStarsIn = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalStarsOut = StarsAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.totalTonIn = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalTonOut = TonAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionStats {
    return {
      $type: TransactionStats.$type,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      totalStarsIn: isSet(object.totalStarsIn) ? StarsAmount.fromJSON(object.totalStarsIn) : undefined,
      totalStarsOut: isSet(object.totalStarsOut) ? StarsAmount.fromJSON(object.totalStarsOut) : undefined,
      totalTonIn: isSet(object.totalTonIn) ? TonAmount.fromJSON(object.totalTonIn) : undefined,
      totalTonOut: isSet(object.totalTonOut) ? TonAmount.fromJSON(object.totalTonOut) : undefined,
    };
  },

  toJSON(message: TransactionStats): unknown {
    const obj: any = {};
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.totalStarsIn !== undefined) {
      obj.totalStarsIn = StarsAmount.toJSON(message.totalStarsIn);
    }
    if (message.totalStarsOut !== undefined) {
      obj.totalStarsOut = StarsAmount.toJSON(message.totalStarsOut);
    }
    if (message.totalTonIn !== undefined) {
      obj.totalTonIn = TonAmount.toJSON(message.totalTonIn);
    }
    if (message.totalTonOut !== undefined) {
      obj.totalTonOut = TonAmount.toJSON(message.totalTonOut);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionStats>, I>>(base?: I): TransactionStats {
    return TransactionStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionStats>, I>>(object: I): TransactionStats {
    const message = createBaseTransactionStats();
    message.totalCount = object.totalCount ?? 0;
    message.totalStarsIn = (object.totalStarsIn !== undefined && object.totalStarsIn !== null)
      ? StarsAmount.fromPartial(object.totalStarsIn)
      : undefined;
    message.totalStarsOut = (object.totalStarsOut !== undefined && object.totalStarsOut !== null)
      ? StarsAmount.fromPartial(object.totalStarsOut)
      : undefined;
    message.totalTonIn = (object.totalTonIn !== undefined && object.totalTonIn !== null)
      ? TonAmount.fromPartial(object.totalTonIn)
      : undefined;
    message.totalTonOut = (object.totalTonOut !== undefined && object.totalTonOut !== null)
      ? TonAmount.fromPartial(object.totalTonOut)
      : undefined;
    return message;
  },
};

function createBaseGetWithdrawalStatusRequest(): GetWithdrawalStatusRequest {
  return { $type: "giftduels.payment.v1.GetWithdrawalStatusRequest", withdrawalId: "" };
}

export const GetWithdrawalStatusRequest: MessageFns<
  GetWithdrawalStatusRequest,
  "giftduels.payment.v1.GetWithdrawalStatusRequest"
> = {
  $type: "giftduels.payment.v1.GetWithdrawalStatusRequest" as const,

  encode(message: GetWithdrawalStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.withdrawalId !== "") {
      writer.uint32(10).string(message.withdrawalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWithdrawalStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWithdrawalStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.withdrawalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWithdrawalStatusRequest {
    return {
      $type: GetWithdrawalStatusRequest.$type,
      withdrawalId: isSet(object.withdrawalId) ? globalThis.String(object.withdrawalId) : "",
    };
  },

  toJSON(message: GetWithdrawalStatusRequest): unknown {
    const obj: any = {};
    if (message.withdrawalId !== "") {
      obj.withdrawalId = message.withdrawalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWithdrawalStatusRequest>, I>>(base?: I): GetWithdrawalStatusRequest {
    return GetWithdrawalStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWithdrawalStatusRequest>, I>>(object: I): GetWithdrawalStatusRequest {
    const message = createBaseGetWithdrawalStatusRequest();
    message.withdrawalId = object.withdrawalId ?? "";
    return message;
  },
};

function createBaseGetWithdrawalStatusResponse(): GetWithdrawalStatusResponse {
  return { $type: "giftduels.payment.v1.GetWithdrawalStatusResponse", withdrawal: undefined };
}

export const GetWithdrawalStatusResponse: MessageFns<
  GetWithdrawalStatusResponse,
  "giftduels.payment.v1.GetWithdrawalStatusResponse"
> = {
  $type: "giftduels.payment.v1.GetWithdrawalStatusResponse" as const,

  encode(message: GetWithdrawalStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.withdrawal !== undefined) {
      TonWithdrawal.encode(message.withdrawal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWithdrawalStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWithdrawalStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.withdrawal = TonWithdrawal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWithdrawalStatusResponse {
    return {
      $type: GetWithdrawalStatusResponse.$type,
      withdrawal: isSet(object.withdrawal) ? TonWithdrawal.fromJSON(object.withdrawal) : undefined,
    };
  },

  toJSON(message: GetWithdrawalStatusResponse): unknown {
    const obj: any = {};
    if (message.withdrawal !== undefined) {
      obj.withdrawal = TonWithdrawal.toJSON(message.withdrawal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWithdrawalStatusResponse>, I>>(base?: I): GetWithdrawalStatusResponse {
    return GetWithdrawalStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWithdrawalStatusResponse>, I>>(object: I): GetWithdrawalStatusResponse {
    const message = createBaseGetWithdrawalStatusResponse();
    message.withdrawal = (object.withdrawal !== undefined && object.withdrawal !== null)
      ? TonWithdrawal.fromPartial(object.withdrawal)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
