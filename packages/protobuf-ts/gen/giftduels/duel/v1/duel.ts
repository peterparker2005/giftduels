// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: giftduels/duel/v1/duel.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { GiftView } from "../../gift/v1/gift";
import {
  DuelId,
  GiftId,
  SortOrder,
  sortOrderFromJSON,
  sortOrderToJSON,
  TonAmount,
  UserDisplayInfo,
} from "../../shared/v1/common";

export enum RoundStatus {
  ROUND_STATUS_UNSPECIFIED = 0,
  ROUND_STATUS_WAITING_FOR_ROLLS = 1,
  ROUND_STATUS_COMPLETED = 2,
  ROUND_STATUS_TIED = 3,
  UNRECOGNIZED = -1,
}

export function roundStatusFromJSON(object: any): RoundStatus {
  switch (object) {
    case 0:
    case "ROUND_STATUS_UNSPECIFIED":
      return RoundStatus.ROUND_STATUS_UNSPECIFIED;
    case 1:
    case "ROUND_STATUS_WAITING_FOR_ROLLS":
      return RoundStatus.ROUND_STATUS_WAITING_FOR_ROLLS;
    case 2:
    case "ROUND_STATUS_COMPLETED":
      return RoundStatus.ROUND_STATUS_COMPLETED;
    case 3:
    case "ROUND_STATUS_TIED":
      return RoundStatus.ROUND_STATUS_TIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoundStatus.UNRECOGNIZED;
  }
}

export function roundStatusToJSON(object: RoundStatus): string {
  switch (object) {
    case RoundStatus.ROUND_STATUS_UNSPECIFIED:
      return "ROUND_STATUS_UNSPECIFIED";
    case RoundStatus.ROUND_STATUS_WAITING_FOR_ROLLS:
      return "ROUND_STATUS_WAITING_FOR_ROLLS";
    case RoundStatus.ROUND_STATUS_COMPLETED:
      return "ROUND_STATUS_COMPLETED";
    case RoundStatus.ROUND_STATUS_TIED:
      return "ROUND_STATUS_TIED";
    case RoundStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ParticipantStatus {
  PARTICIPANT_STATUS_UNSPECIFIED = 0,
  PARTICIPANT_STATUS_JOINED = 1,
  PARTICIPANT_STATUS_READY = 2,
  PARTICIPANT_STATUS_ACTIVE = 3,
  PARTICIPANT_STATUS_DISCONNECTED = 4,
  UNRECOGNIZED = -1,
}

export function participantStatusFromJSON(object: any): ParticipantStatus {
  switch (object) {
    case 0:
    case "PARTICIPANT_STATUS_UNSPECIFIED":
      return ParticipantStatus.PARTICIPANT_STATUS_UNSPECIFIED;
    case 1:
    case "PARTICIPANT_STATUS_JOINED":
      return ParticipantStatus.PARTICIPANT_STATUS_JOINED;
    case 2:
    case "PARTICIPANT_STATUS_READY":
      return ParticipantStatus.PARTICIPANT_STATUS_READY;
    case 3:
    case "PARTICIPANT_STATUS_ACTIVE":
      return ParticipantStatus.PARTICIPANT_STATUS_ACTIVE;
    case 4:
    case "PARTICIPANT_STATUS_DISCONNECTED":
      return ParticipantStatus.PARTICIPANT_STATUS_DISCONNECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParticipantStatus.UNRECOGNIZED;
  }
}

export function participantStatusToJSON(object: ParticipantStatus): string {
  switch (object) {
    case ParticipantStatus.PARTICIPANT_STATUS_UNSPECIFIED:
      return "PARTICIPANT_STATUS_UNSPECIFIED";
    case ParticipantStatus.PARTICIPANT_STATUS_JOINED:
      return "PARTICIPANT_STATUS_JOINED";
    case ParticipantStatus.PARTICIPANT_STATUS_READY:
      return "PARTICIPANT_STATUS_READY";
    case ParticipantStatus.PARTICIPANT_STATUS_ACTIVE:
      return "PARTICIPANT_STATUS_ACTIVE";
    case ParticipantStatus.PARTICIPANT_STATUS_DISCONNECTED:
      return "PARTICIPANT_STATUS_DISCONNECTED";
    case ParticipantStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DuelSortField {
  DUEL_SORT_FIELD_UNSPECIFIED = 0,
  DUEL_SORT_FIELD_CREATED_AT = 1,
  DUEL_SORT_FIELD_TOTAL_VALUE = 2,
  DUEL_SORT_FIELD_COMPLETED_AT = 3,
  UNRECOGNIZED = -1,
}

export function duelSortFieldFromJSON(object: any): DuelSortField {
  switch (object) {
    case 0:
    case "DUEL_SORT_FIELD_UNSPECIFIED":
      return DuelSortField.DUEL_SORT_FIELD_UNSPECIFIED;
    case 1:
    case "DUEL_SORT_FIELD_CREATED_AT":
      return DuelSortField.DUEL_SORT_FIELD_CREATED_AT;
    case 2:
    case "DUEL_SORT_FIELD_TOTAL_VALUE":
      return DuelSortField.DUEL_SORT_FIELD_TOTAL_VALUE;
    case 3:
    case "DUEL_SORT_FIELD_COMPLETED_AT":
      return DuelSortField.DUEL_SORT_FIELD_COMPLETED_AT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DuelSortField.UNRECOGNIZED;
  }
}

export function duelSortFieldToJSON(object: DuelSortField): string {
  switch (object) {
    case DuelSortField.DUEL_SORT_FIELD_UNSPECIFIED:
      return "DUEL_SORT_FIELD_UNSPECIFIED";
    case DuelSortField.DUEL_SORT_FIELD_CREATED_AT:
      return "DUEL_SORT_FIELD_CREATED_AT";
    case DuelSortField.DUEL_SORT_FIELD_TOTAL_VALUE:
      return "DUEL_SORT_FIELD_TOTAL_VALUE";
    case DuelSortField.DUEL_SORT_FIELD_COMPLETED_AT:
      return "DUEL_SORT_FIELD_COMPLETED_AT";
    case DuelSortField.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GameStatus {
  GAME_STATUS_UNSPECIFIED = 0,
  GAME_STATUS_OPEN = 1,
  GAME_STATUS_IN_PROGRESS = 2,
  GAME_STATUS_FINISHED = 3,
  GAME_STATUS_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function gameStatusFromJSON(object: any): GameStatus {
  switch (object) {
    case 0:
    case "GAME_STATUS_UNSPECIFIED":
      return GameStatus.GAME_STATUS_UNSPECIFIED;
    case 1:
    case "GAME_STATUS_OPEN":
      return GameStatus.GAME_STATUS_OPEN;
    case 2:
    case "GAME_STATUS_IN_PROGRESS":
      return GameStatus.GAME_STATUS_IN_PROGRESS;
    case 3:
    case "GAME_STATUS_FINISHED":
      return GameStatus.GAME_STATUS_FINISHED;
    case 4:
    case "GAME_STATUS_CANCELLED":
      return GameStatus.GAME_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameStatus.UNRECOGNIZED;
  }
}

export function gameStatusToJSON(object: GameStatus): string {
  switch (object) {
    case GameStatus.GAME_STATUS_UNSPECIFIED:
      return "GAME_STATUS_UNSPECIFIED";
    case GameStatus.GAME_STATUS_OPEN:
      return "GAME_STATUS_OPEN";
    case GameStatus.GAME_STATUS_IN_PROGRESS:
      return "GAME_STATUS_IN_PROGRESS";
    case GameStatus.GAME_STATUS_FINISHED:
      return "GAME_STATUS_FINISHED";
    case GameStatus.GAME_STATUS_CANCELLED:
      return "GAME_STATUS_CANCELLED";
    case GameStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DuelParams {
  $type: "giftduels.duel.v1.DuelParams";
  inviteOnly: boolean;
  autoRollTimeout:
    | Duration
    | undefined;
  /** Maximum rounds before draw */
  maxRounds: number;
}

export interface DuelInviteParams {
  $type: "giftduels.duel.v1.DuelInviteParams";
  inviteOnly: boolean;
  autoRollTimeout: Duration | undefined;
}

export interface DiceRoll {
  $type: "giftduels.duel.v1.DiceRoll";
  telegramUserId: string;
  roundNumber: number;
  /** 1-6 */
  value: number;
  /** true if manually rolled, false if auto-rolled */
  isManual: boolean;
  rolledAt: Date | undefined;
}

export interface RoundInfo {
  $type: "giftduels.duel.v1.RoundInfo";
  roundNumber: number;
  /** key: user_id, value: roll */
  rolls: { [key: string]: DiceRoll };
  status: RoundStatus;
  /** Set if round has winner */
  winnerUserId: string;
}

export interface RoundInfo_RollsEntry {
  $type: "giftduels.duel.v1.RoundInfo.RollsEntry";
  key: string;
  value: DiceRoll | undefined;
}

export interface DuelParticipant {
  $type: "giftduels.duel.v1.DuelParticipant";
  telegramUserId: string;
  userInfo: UserDisplayInfo | undefined;
  isCreator: boolean;
  stakes: DuelStakeItem[];
  totalStakeValue: TonAmount | undefined;
  status: ParticipantStatus;
}

export interface DuelParticipants {
  $type: "giftduels.duel.v1.DuelParticipants";
  creator: DuelParticipant | undefined;
  opponent: DuelParticipant | undefined;
}

export interface DuelStakeItem {
  $type: "giftduels.duel.v1.DuelStakeItem";
  giftId: GiftId | undefined;
  giftInfo: GiftView | undefined;
}

export interface Duel {
  $type: "giftduels.duel.v1.Duel";
  duelId: DuelId | undefined;
  params: DuelParams | undefined;
  participants:
    | DuelParticipants
    | undefined;
  /** Game state */
  currentRound: number;
  roundsHistory: RoundInfo[];
  winnerUserId: string;
  /** Timing */
  nextRollDeadline:
    | Date
    | undefined;
  /** Total stakes */
  totalStakeValue:
    | TonAmount
    | undefined;
  /** Status and timestamps */
  status: GameStatus;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  completedAt: Date | undefined;
}

export interface DuelSummary {
  $type: "giftduels.duel.v1.DuelSummary";
  duelId: DuelId | undefined;
  currentRound: number;
  /** Quick access to current round rolls */
  currentRoundRolls: { [key: string]: DiceRoll };
  winnerUserId: string;
  totalStakeValue: TonAmount | undefined;
  participants: DuelParticipants | undefined;
  nextRollDeadline: Date | undefined;
  rollTimeout: Duration | undefined;
  status: GameStatus;
}

export interface DuelSummary_CurrentRoundRollsEntry {
  $type: "giftduels.duel.v1.DuelSummary.CurrentRoundRollsEntry";
  key: string;
  value: DiceRoll | undefined;
}

export interface DuelListItem {
  $type: "giftduels.duel.v1.DuelListItem";
  duelId: DuelId | undefined;
  status: GameStatus;
  participants: DuelParticipants | undefined;
  totalStakeValue: TonAmount | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  completedAt: Date | undefined;
  inviteOnly: boolean;
}

export interface DuelFilters {
  $type: "giftduels.duel.v1.DuelFilters";
  /** Статус комнаты (open/in-progress/finished/history) */
  status: GameStatus;
  /** Только invite-only комнаты */
  inviteOnly: boolean;
  /** Фильтр по создателю или участнику */
  isCreator: boolean;
  isParticipant: boolean;
}

export interface DuelSortOptions {
  $type: "giftduels.duel.v1.DuelSortOptions";
  field: DuelSortField;
  order: SortOrder;
}

function createBaseDuelParams(): DuelParams {
  return { $type: "giftduels.duel.v1.DuelParams", inviteOnly: false, autoRollTimeout: undefined, maxRounds: 0 };
}

export const DuelParams: MessageFns<DuelParams, "giftduels.duel.v1.DuelParams"> = {
  $type: "giftduels.duel.v1.DuelParams" as const,

  encode(message: DuelParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inviteOnly !== false) {
      writer.uint32(8).bool(message.inviteOnly);
    }
    if (message.autoRollTimeout !== undefined) {
      Duration.encode(message.autoRollTimeout, writer.uint32(18).fork()).join();
    }
    if (message.maxRounds !== 0) {
      writer.uint32(24).uint32(message.maxRounds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inviteOnly = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.autoRollTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxRounds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelParams {
    return {
      $type: DuelParams.$type,
      inviteOnly: isSet(object.inviteOnly) ? globalThis.Boolean(object.inviteOnly) : false,
      autoRollTimeout: isSet(object.autoRollTimeout) ? Duration.fromJSON(object.autoRollTimeout) : undefined,
      maxRounds: isSet(object.maxRounds) ? globalThis.Number(object.maxRounds) : 0,
    };
  },

  toJSON(message: DuelParams): unknown {
    const obj: any = {};
    if (message.inviteOnly !== false) {
      obj.inviteOnly = message.inviteOnly;
    }
    if (message.autoRollTimeout !== undefined) {
      obj.autoRollTimeout = Duration.toJSON(message.autoRollTimeout);
    }
    if (message.maxRounds !== 0) {
      obj.maxRounds = Math.round(message.maxRounds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelParams>, I>>(base?: I): DuelParams {
    return DuelParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelParams>, I>>(object: I): DuelParams {
    const message = createBaseDuelParams();
    message.inviteOnly = object.inviteOnly ?? false;
    message.autoRollTimeout = (object.autoRollTimeout !== undefined && object.autoRollTimeout !== null)
      ? Duration.fromPartial(object.autoRollTimeout)
      : undefined;
    message.maxRounds = object.maxRounds ?? 0;
    return message;
  },
};

function createBaseDuelInviteParams(): DuelInviteParams {
  return { $type: "giftduels.duel.v1.DuelInviteParams", inviteOnly: false, autoRollTimeout: undefined };
}

export const DuelInviteParams: MessageFns<DuelInviteParams, "giftduels.duel.v1.DuelInviteParams"> = {
  $type: "giftduels.duel.v1.DuelInviteParams" as const,

  encode(message: DuelInviteParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inviteOnly !== false) {
      writer.uint32(8).bool(message.inviteOnly);
    }
    if (message.autoRollTimeout !== undefined) {
      Duration.encode(message.autoRollTimeout, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelInviteParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelInviteParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inviteOnly = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.autoRollTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelInviteParams {
    return {
      $type: DuelInviteParams.$type,
      inviteOnly: isSet(object.inviteOnly) ? globalThis.Boolean(object.inviteOnly) : false,
      autoRollTimeout: isSet(object.autoRollTimeout) ? Duration.fromJSON(object.autoRollTimeout) : undefined,
    };
  },

  toJSON(message: DuelInviteParams): unknown {
    const obj: any = {};
    if (message.inviteOnly !== false) {
      obj.inviteOnly = message.inviteOnly;
    }
    if (message.autoRollTimeout !== undefined) {
      obj.autoRollTimeout = Duration.toJSON(message.autoRollTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelInviteParams>, I>>(base?: I): DuelInviteParams {
    return DuelInviteParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelInviteParams>, I>>(object: I): DuelInviteParams {
    const message = createBaseDuelInviteParams();
    message.inviteOnly = object.inviteOnly ?? false;
    message.autoRollTimeout = (object.autoRollTimeout !== undefined && object.autoRollTimeout !== null)
      ? Duration.fromPartial(object.autoRollTimeout)
      : undefined;
    return message;
  },
};

function createBaseDiceRoll(): DiceRoll {
  return {
    $type: "giftduels.duel.v1.DiceRoll",
    telegramUserId: "0",
    roundNumber: 0,
    value: 0,
    isManual: false,
    rolledAt: undefined,
  };
}

export const DiceRoll: MessageFns<DiceRoll, "giftduels.duel.v1.DiceRoll"> = {
  $type: "giftduels.duel.v1.DiceRoll" as const,

  encode(message: DiceRoll, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.telegramUserId !== "0") {
      writer.uint32(8).int64(message.telegramUserId);
    }
    if (message.roundNumber !== 0) {
      writer.uint32(16).int32(message.roundNumber);
    }
    if (message.value !== 0) {
      writer.uint32(24).int32(message.value);
    }
    if (message.isManual !== false) {
      writer.uint32(32).bool(message.isManual);
    }
    if (message.rolledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.rolledAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiceRoll {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiceRoll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.telegramUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roundNumber = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isManual = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rolledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiceRoll {
    return {
      $type: DiceRoll.$type,
      telegramUserId: isSet(object.telegramUserId) ? globalThis.String(object.telegramUserId) : "0",
      roundNumber: isSet(object.roundNumber) ? globalThis.Number(object.roundNumber) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      isManual: isSet(object.isManual) ? globalThis.Boolean(object.isManual) : false,
      rolledAt: isSet(object.rolledAt) ? fromJsonTimestamp(object.rolledAt) : undefined,
    };
  },

  toJSON(message: DiceRoll): unknown {
    const obj: any = {};
    if (message.telegramUserId !== "0") {
      obj.telegramUserId = message.telegramUserId;
    }
    if (message.roundNumber !== 0) {
      obj.roundNumber = Math.round(message.roundNumber);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.isManual !== false) {
      obj.isManual = message.isManual;
    }
    if (message.rolledAt !== undefined) {
      obj.rolledAt = message.rolledAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiceRoll>, I>>(base?: I): DiceRoll {
    return DiceRoll.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiceRoll>, I>>(object: I): DiceRoll {
    const message = createBaseDiceRoll();
    message.telegramUserId = object.telegramUserId ?? "0";
    message.roundNumber = object.roundNumber ?? 0;
    message.value = object.value ?? 0;
    message.isManual = object.isManual ?? false;
    message.rolledAt = object.rolledAt ?? undefined;
    return message;
  },
};

function createBaseRoundInfo(): RoundInfo {
  return { $type: "giftduels.duel.v1.RoundInfo", roundNumber: 0, rolls: {}, status: 0, winnerUserId: "0" };
}

export const RoundInfo: MessageFns<RoundInfo, "giftduels.duel.v1.RoundInfo"> = {
  $type: "giftduels.duel.v1.RoundInfo" as const,

  encode(message: RoundInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roundNumber !== 0) {
      writer.uint32(8).int32(message.roundNumber);
    }
    Object.entries(message.rolls).forEach(([key, value]) => {
      RoundInfo_RollsEntry.encode(
        { $type: "giftduels.duel.v1.RoundInfo.RollsEntry", key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.winnerUserId !== "0") {
      writer.uint32(32).int64(message.winnerUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoundInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoundInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roundNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = RoundInfo_RollsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.rolls[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.winnerUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoundInfo {
    return {
      $type: RoundInfo.$type,
      roundNumber: isSet(object.roundNumber) ? globalThis.Number(object.roundNumber) : 0,
      rolls: isObject(object.rolls)
        ? Object.entries(object.rolls).reduce<{ [key: string]: DiceRoll }>((acc, [key, value]) => {
          acc[key] = DiceRoll.fromJSON(value);
          return acc;
        }, {})
        : {},
      status: isSet(object.status) ? roundStatusFromJSON(object.status) : 0,
      winnerUserId: isSet(object.winnerUserId) ? globalThis.String(object.winnerUserId) : "0",
    };
  },

  toJSON(message: RoundInfo): unknown {
    const obj: any = {};
    if (message.roundNumber !== 0) {
      obj.roundNumber = Math.round(message.roundNumber);
    }
    if (message.rolls) {
      const entries = Object.entries(message.rolls);
      if (entries.length > 0) {
        obj.rolls = {};
        entries.forEach(([k, v]) => {
          obj.rolls[k] = DiceRoll.toJSON(v);
        });
      }
    }
    if (message.status !== 0) {
      obj.status = roundStatusToJSON(message.status);
    }
    if (message.winnerUserId !== "0") {
      obj.winnerUserId = message.winnerUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoundInfo>, I>>(base?: I): RoundInfo {
    return RoundInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoundInfo>, I>>(object: I): RoundInfo {
    const message = createBaseRoundInfo();
    message.roundNumber = object.roundNumber ?? 0;
    message.rolls = Object.entries(object.rolls ?? {}).reduce<{ [key: string]: DiceRoll }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DiceRoll.fromPartial(value);
      }
      return acc;
    }, {});
    message.status = object.status ?? 0;
    message.winnerUserId = object.winnerUserId ?? "0";
    return message;
  },
};

function createBaseRoundInfo_RollsEntry(): RoundInfo_RollsEntry {
  return { $type: "giftduels.duel.v1.RoundInfo.RollsEntry", key: "", value: undefined };
}

export const RoundInfo_RollsEntry: MessageFns<RoundInfo_RollsEntry, "giftduels.duel.v1.RoundInfo.RollsEntry"> = {
  $type: "giftduels.duel.v1.RoundInfo.RollsEntry" as const,

  encode(message: RoundInfo_RollsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DiceRoll.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoundInfo_RollsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoundInfo_RollsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DiceRoll.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoundInfo_RollsEntry {
    return {
      $type: RoundInfo_RollsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DiceRoll.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RoundInfo_RollsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DiceRoll.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoundInfo_RollsEntry>, I>>(base?: I): RoundInfo_RollsEntry {
    return RoundInfo_RollsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoundInfo_RollsEntry>, I>>(object: I): RoundInfo_RollsEntry {
    const message = createBaseRoundInfo_RollsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DiceRoll.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDuelParticipant(): DuelParticipant {
  return {
    $type: "giftduels.duel.v1.DuelParticipant",
    telegramUserId: "0",
    userInfo: undefined,
    isCreator: false,
    stakes: [],
    totalStakeValue: undefined,
    status: 0,
  };
}

export const DuelParticipant: MessageFns<DuelParticipant, "giftduels.duel.v1.DuelParticipant"> = {
  $type: "giftduels.duel.v1.DuelParticipant" as const,

  encode(message: DuelParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.telegramUserId !== "0") {
      writer.uint32(8).int64(message.telegramUserId);
    }
    if (message.userInfo !== undefined) {
      UserDisplayInfo.encode(message.userInfo, writer.uint32(18).fork()).join();
    }
    if (message.isCreator !== false) {
      writer.uint32(24).bool(message.isCreator);
    }
    for (const v of message.stakes) {
      DuelStakeItem.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.totalStakeValue !== undefined) {
      TonAmount.encode(message.totalStakeValue, writer.uint32(42).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.telegramUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userInfo = UserDisplayInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isCreator = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stakes.push(DuelStakeItem.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalStakeValue = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelParticipant {
    return {
      $type: DuelParticipant.$type,
      telegramUserId: isSet(object.telegramUserId) ? globalThis.String(object.telegramUserId) : "0",
      userInfo: isSet(object.userInfo) ? UserDisplayInfo.fromJSON(object.userInfo) : undefined,
      isCreator: isSet(object.isCreator) ? globalThis.Boolean(object.isCreator) : false,
      stakes: globalThis.Array.isArray(object?.stakes) ? object.stakes.map((e: any) => DuelStakeItem.fromJSON(e)) : [],
      totalStakeValue: isSet(object.totalStakeValue) ? TonAmount.fromJSON(object.totalStakeValue) : undefined,
      status: isSet(object.status) ? participantStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: DuelParticipant): unknown {
    const obj: any = {};
    if (message.telegramUserId !== "0") {
      obj.telegramUserId = message.telegramUserId;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserDisplayInfo.toJSON(message.userInfo);
    }
    if (message.isCreator !== false) {
      obj.isCreator = message.isCreator;
    }
    if (message.stakes?.length) {
      obj.stakes = message.stakes.map((e) => DuelStakeItem.toJSON(e));
    }
    if (message.totalStakeValue !== undefined) {
      obj.totalStakeValue = TonAmount.toJSON(message.totalStakeValue);
    }
    if (message.status !== 0) {
      obj.status = participantStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelParticipant>, I>>(base?: I): DuelParticipant {
    return DuelParticipant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelParticipant>, I>>(object: I): DuelParticipant {
    const message = createBaseDuelParticipant();
    message.telegramUserId = object.telegramUserId ?? "0";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserDisplayInfo.fromPartial(object.userInfo)
      : undefined;
    message.isCreator = object.isCreator ?? false;
    message.stakes = object.stakes?.map((e) => DuelStakeItem.fromPartial(e)) || [];
    message.totalStakeValue = (object.totalStakeValue !== undefined && object.totalStakeValue !== null)
      ? TonAmount.fromPartial(object.totalStakeValue)
      : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseDuelParticipants(): DuelParticipants {
  return { $type: "giftduels.duel.v1.DuelParticipants", creator: undefined, opponent: undefined };
}

export const DuelParticipants: MessageFns<DuelParticipants, "giftduels.duel.v1.DuelParticipants"> = {
  $type: "giftduels.duel.v1.DuelParticipants" as const,

  encode(message: DuelParticipants, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== undefined) {
      DuelParticipant.encode(message.creator, writer.uint32(10).fork()).join();
    }
    if (message.opponent !== undefined) {
      DuelParticipant.encode(message.opponent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelParticipants {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelParticipants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = DuelParticipant.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opponent = DuelParticipant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelParticipants {
    return {
      $type: DuelParticipants.$type,
      creator: isSet(object.creator) ? DuelParticipant.fromJSON(object.creator) : undefined,
      opponent: isSet(object.opponent) ? DuelParticipant.fromJSON(object.opponent) : undefined,
    };
  },

  toJSON(message: DuelParticipants): unknown {
    const obj: any = {};
    if (message.creator !== undefined) {
      obj.creator = DuelParticipant.toJSON(message.creator);
    }
    if (message.opponent !== undefined) {
      obj.opponent = DuelParticipant.toJSON(message.opponent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelParticipants>, I>>(base?: I): DuelParticipants {
    return DuelParticipants.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelParticipants>, I>>(object: I): DuelParticipants {
    const message = createBaseDuelParticipants();
    message.creator = (object.creator !== undefined && object.creator !== null)
      ? DuelParticipant.fromPartial(object.creator)
      : undefined;
    message.opponent = (object.opponent !== undefined && object.opponent !== null)
      ? DuelParticipant.fromPartial(object.opponent)
      : undefined;
    return message;
  },
};

function createBaseDuelStakeItem(): DuelStakeItem {
  return { $type: "giftduels.duel.v1.DuelStakeItem", giftId: undefined, giftInfo: undefined };
}

export const DuelStakeItem: MessageFns<DuelStakeItem, "giftduels.duel.v1.DuelStakeItem"> = {
  $type: "giftduels.duel.v1.DuelStakeItem" as const,

  encode(message: DuelStakeItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== undefined) {
      GiftId.encode(message.giftId, writer.uint32(10).fork()).join();
    }
    if (message.giftInfo !== undefined) {
      GiftView.encode(message.giftInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelStakeItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelStakeItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftId = GiftId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftInfo = GiftView.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelStakeItem {
    return {
      $type: DuelStakeItem.$type,
      giftId: isSet(object.giftId) ? GiftId.fromJSON(object.giftId) : undefined,
      giftInfo: isSet(object.giftInfo) ? GiftView.fromJSON(object.giftInfo) : undefined,
    };
  },

  toJSON(message: DuelStakeItem): unknown {
    const obj: any = {};
    if (message.giftId !== undefined) {
      obj.giftId = GiftId.toJSON(message.giftId);
    }
    if (message.giftInfo !== undefined) {
      obj.giftInfo = GiftView.toJSON(message.giftInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelStakeItem>, I>>(base?: I): DuelStakeItem {
    return DuelStakeItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelStakeItem>, I>>(object: I): DuelStakeItem {
    const message = createBaseDuelStakeItem();
    message.giftId = (object.giftId !== undefined && object.giftId !== null)
      ? GiftId.fromPartial(object.giftId)
      : undefined;
    message.giftInfo = (object.giftInfo !== undefined && object.giftInfo !== null)
      ? GiftView.fromPartial(object.giftInfo)
      : undefined;
    return message;
  },
};

function createBaseDuel(): Duel {
  return {
    $type: "giftduels.duel.v1.Duel",
    duelId: undefined,
    params: undefined,
    participants: undefined,
    currentRound: 0,
    roundsHistory: [],
    winnerUserId: "0",
    nextRollDeadline: undefined,
    totalStakeValue: undefined,
    status: 0,
    createdAt: undefined,
    updatedAt: undefined,
    completedAt: undefined,
  };
}

export const Duel: MessageFns<Duel, "giftduels.duel.v1.Duel"> = {
  $type: "giftduels.duel.v1.Duel" as const,

  encode(message: Duel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duelId !== undefined) {
      DuelId.encode(message.duelId, writer.uint32(10).fork()).join();
    }
    if (message.params !== undefined) {
      DuelParams.encode(message.params, writer.uint32(18).fork()).join();
    }
    if (message.participants !== undefined) {
      DuelParticipants.encode(message.participants, writer.uint32(26).fork()).join();
    }
    if (message.currentRound !== 0) {
      writer.uint32(32).int32(message.currentRound);
    }
    for (const v of message.roundsHistory) {
      RoundInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.winnerUserId !== "0") {
      writer.uint32(48).int64(message.winnerUserId);
    }
    if (message.nextRollDeadline !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRollDeadline), writer.uint32(58).fork()).join();
    }
    if (message.totalStakeValue !== undefined) {
      TonAmount.encode(message.totalStakeValue, writer.uint32(66).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Duel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.duelId = DuelId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = DuelParams.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participants = DuelParticipants.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentRound = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roundsHistory.push(RoundInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.winnerUserId = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nextRollDeadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.totalStakeValue = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Duel {
    return {
      $type: Duel.$type,
      duelId: isSet(object.duelId) ? DuelId.fromJSON(object.duelId) : undefined,
      params: isSet(object.params) ? DuelParams.fromJSON(object.params) : undefined,
      participants: isSet(object.participants) ? DuelParticipants.fromJSON(object.participants) : undefined,
      currentRound: isSet(object.currentRound) ? globalThis.Number(object.currentRound) : 0,
      roundsHistory: globalThis.Array.isArray(object?.roundsHistory)
        ? object.roundsHistory.map((e: any) => RoundInfo.fromJSON(e))
        : [],
      winnerUserId: isSet(object.winnerUserId) ? globalThis.String(object.winnerUserId) : "0",
      nextRollDeadline: isSet(object.nextRollDeadline) ? fromJsonTimestamp(object.nextRollDeadline) : undefined,
      totalStakeValue: isSet(object.totalStakeValue) ? TonAmount.fromJSON(object.totalStakeValue) : undefined,
      status: isSet(object.status) ? gameStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
    };
  },

  toJSON(message: Duel): unknown {
    const obj: any = {};
    if (message.duelId !== undefined) {
      obj.duelId = DuelId.toJSON(message.duelId);
    }
    if (message.params !== undefined) {
      obj.params = DuelParams.toJSON(message.params);
    }
    if (message.participants !== undefined) {
      obj.participants = DuelParticipants.toJSON(message.participants);
    }
    if (message.currentRound !== 0) {
      obj.currentRound = Math.round(message.currentRound);
    }
    if (message.roundsHistory?.length) {
      obj.roundsHistory = message.roundsHistory.map((e) => RoundInfo.toJSON(e));
    }
    if (message.winnerUserId !== "0") {
      obj.winnerUserId = message.winnerUserId;
    }
    if (message.nextRollDeadline !== undefined) {
      obj.nextRollDeadline = message.nextRollDeadline.toISOString();
    }
    if (message.totalStakeValue !== undefined) {
      obj.totalStakeValue = TonAmount.toJSON(message.totalStakeValue);
    }
    if (message.status !== 0) {
      obj.status = gameStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Duel>, I>>(base?: I): Duel {
    return Duel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Duel>, I>>(object: I): Duel {
    const message = createBaseDuel();
    message.duelId = (object.duelId !== undefined && object.duelId !== null)
      ? DuelId.fromPartial(object.duelId)
      : undefined;
    message.params = (object.params !== undefined && object.params !== null)
      ? DuelParams.fromPartial(object.params)
      : undefined;
    message.participants = (object.participants !== undefined && object.participants !== null)
      ? DuelParticipants.fromPartial(object.participants)
      : undefined;
    message.currentRound = object.currentRound ?? 0;
    message.roundsHistory = object.roundsHistory?.map((e) => RoundInfo.fromPartial(e)) || [];
    message.winnerUserId = object.winnerUserId ?? "0";
    message.nextRollDeadline = object.nextRollDeadline ?? undefined;
    message.totalStakeValue = (object.totalStakeValue !== undefined && object.totalStakeValue !== null)
      ? TonAmount.fromPartial(object.totalStakeValue)
      : undefined;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    return message;
  },
};

function createBaseDuelSummary(): DuelSummary {
  return {
    $type: "giftduels.duel.v1.DuelSummary",
    duelId: undefined,
    currentRound: 0,
    currentRoundRolls: {},
    winnerUserId: "0",
    totalStakeValue: undefined,
    participants: undefined,
    nextRollDeadline: undefined,
    rollTimeout: undefined,
    status: 0,
  };
}

export const DuelSummary: MessageFns<DuelSummary, "giftduels.duel.v1.DuelSummary"> = {
  $type: "giftduels.duel.v1.DuelSummary" as const,

  encode(message: DuelSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duelId !== undefined) {
      DuelId.encode(message.duelId, writer.uint32(10).fork()).join();
    }
    if (message.currentRound !== 0) {
      writer.uint32(16).int32(message.currentRound);
    }
    Object.entries(message.currentRoundRolls).forEach(([key, value]) => {
      DuelSummary_CurrentRoundRollsEntry.encode({
        $type: "giftduels.duel.v1.DuelSummary.CurrentRoundRollsEntry",
        key: key as any,
        value,
      }, writer.uint32(26).fork()).join();
    });
    if (message.winnerUserId !== "0") {
      writer.uint32(32).int64(message.winnerUserId);
    }
    if (message.totalStakeValue !== undefined) {
      TonAmount.encode(message.totalStakeValue, writer.uint32(42).fork()).join();
    }
    if (message.participants !== undefined) {
      DuelParticipants.encode(message.participants, writer.uint32(50).fork()).join();
    }
    if (message.nextRollDeadline !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRollDeadline), writer.uint32(58).fork()).join();
    }
    if (message.rollTimeout !== undefined) {
      Duration.encode(message.rollTimeout, writer.uint32(66).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.duelId = DuelId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentRound = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = DuelSummary_CurrentRoundRollsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.currentRoundRolls[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.winnerUserId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalStakeValue = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.participants = DuelParticipants.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nextRollDeadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rollTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelSummary {
    return {
      $type: DuelSummary.$type,
      duelId: isSet(object.duelId) ? DuelId.fromJSON(object.duelId) : undefined,
      currentRound: isSet(object.currentRound) ? globalThis.Number(object.currentRound) : 0,
      currentRoundRolls: isObject(object.currentRoundRolls)
        ? Object.entries(object.currentRoundRolls).reduce<{ [key: string]: DiceRoll }>((acc, [key, value]) => {
          acc[key] = DiceRoll.fromJSON(value);
          return acc;
        }, {})
        : {},
      winnerUserId: isSet(object.winnerUserId) ? globalThis.String(object.winnerUserId) : "0",
      totalStakeValue: isSet(object.totalStakeValue) ? TonAmount.fromJSON(object.totalStakeValue) : undefined,
      participants: isSet(object.participants) ? DuelParticipants.fromJSON(object.participants) : undefined,
      nextRollDeadline: isSet(object.nextRollDeadline) ? fromJsonTimestamp(object.nextRollDeadline) : undefined,
      rollTimeout: isSet(object.rollTimeout) ? Duration.fromJSON(object.rollTimeout) : undefined,
      status: isSet(object.status) ? gameStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: DuelSummary): unknown {
    const obj: any = {};
    if (message.duelId !== undefined) {
      obj.duelId = DuelId.toJSON(message.duelId);
    }
    if (message.currentRound !== 0) {
      obj.currentRound = Math.round(message.currentRound);
    }
    if (message.currentRoundRolls) {
      const entries = Object.entries(message.currentRoundRolls);
      if (entries.length > 0) {
        obj.currentRoundRolls = {};
        entries.forEach(([k, v]) => {
          obj.currentRoundRolls[k] = DiceRoll.toJSON(v);
        });
      }
    }
    if (message.winnerUserId !== "0") {
      obj.winnerUserId = message.winnerUserId;
    }
    if (message.totalStakeValue !== undefined) {
      obj.totalStakeValue = TonAmount.toJSON(message.totalStakeValue);
    }
    if (message.participants !== undefined) {
      obj.participants = DuelParticipants.toJSON(message.participants);
    }
    if (message.nextRollDeadline !== undefined) {
      obj.nextRollDeadline = message.nextRollDeadline.toISOString();
    }
    if (message.rollTimeout !== undefined) {
      obj.rollTimeout = Duration.toJSON(message.rollTimeout);
    }
    if (message.status !== 0) {
      obj.status = gameStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelSummary>, I>>(base?: I): DuelSummary {
    return DuelSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelSummary>, I>>(object: I): DuelSummary {
    const message = createBaseDuelSummary();
    message.duelId = (object.duelId !== undefined && object.duelId !== null)
      ? DuelId.fromPartial(object.duelId)
      : undefined;
    message.currentRound = object.currentRound ?? 0;
    message.currentRoundRolls = Object.entries(object.currentRoundRolls ?? {}).reduce<{ [key: string]: DiceRoll }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DiceRoll.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.winnerUserId = object.winnerUserId ?? "0";
    message.totalStakeValue = (object.totalStakeValue !== undefined && object.totalStakeValue !== null)
      ? TonAmount.fromPartial(object.totalStakeValue)
      : undefined;
    message.participants = (object.participants !== undefined && object.participants !== null)
      ? DuelParticipants.fromPartial(object.participants)
      : undefined;
    message.nextRollDeadline = object.nextRollDeadline ?? undefined;
    message.rollTimeout = (object.rollTimeout !== undefined && object.rollTimeout !== null)
      ? Duration.fromPartial(object.rollTimeout)
      : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseDuelSummary_CurrentRoundRollsEntry(): DuelSummary_CurrentRoundRollsEntry {
  return { $type: "giftduels.duel.v1.DuelSummary.CurrentRoundRollsEntry", key: "", value: undefined };
}

export const DuelSummary_CurrentRoundRollsEntry: MessageFns<
  DuelSummary_CurrentRoundRollsEntry,
  "giftduels.duel.v1.DuelSummary.CurrentRoundRollsEntry"
> = {
  $type: "giftduels.duel.v1.DuelSummary.CurrentRoundRollsEntry" as const,

  encode(message: DuelSummary_CurrentRoundRollsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DiceRoll.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelSummary_CurrentRoundRollsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelSummary_CurrentRoundRollsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DiceRoll.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelSummary_CurrentRoundRollsEntry {
    return {
      $type: DuelSummary_CurrentRoundRollsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DiceRoll.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DuelSummary_CurrentRoundRollsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DiceRoll.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelSummary_CurrentRoundRollsEntry>, I>>(
    base?: I,
  ): DuelSummary_CurrentRoundRollsEntry {
    return DuelSummary_CurrentRoundRollsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelSummary_CurrentRoundRollsEntry>, I>>(
    object: I,
  ): DuelSummary_CurrentRoundRollsEntry {
    const message = createBaseDuelSummary_CurrentRoundRollsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DiceRoll.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDuelListItem(): DuelListItem {
  return {
    $type: "giftduels.duel.v1.DuelListItem",
    duelId: undefined,
    status: 0,
    participants: undefined,
    totalStakeValue: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    completedAt: undefined,
    inviteOnly: false,
  };
}

export const DuelListItem: MessageFns<DuelListItem, "giftduels.duel.v1.DuelListItem"> = {
  $type: "giftduels.duel.v1.DuelListItem" as const,

  encode(message: DuelListItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duelId !== undefined) {
      DuelId.encode(message.duelId, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.participants !== undefined) {
      DuelParticipants.encode(message.participants, writer.uint32(26).fork()).join();
    }
    if (message.totalStakeValue !== undefined) {
      TonAmount.encode(message.totalStakeValue, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(58).fork()).join();
    }
    if (message.inviteOnly !== false) {
      writer.uint32(64).bool(message.inviteOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelListItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.duelId = DuelId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participants = DuelParticipants.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.totalStakeValue = TonAmount.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.inviteOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelListItem {
    return {
      $type: DuelListItem.$type,
      duelId: isSet(object.duelId) ? DuelId.fromJSON(object.duelId) : undefined,
      status: isSet(object.status) ? gameStatusFromJSON(object.status) : 0,
      participants: isSet(object.participants) ? DuelParticipants.fromJSON(object.participants) : undefined,
      totalStakeValue: isSet(object.totalStakeValue) ? TonAmount.fromJSON(object.totalStakeValue) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      inviteOnly: isSet(object.inviteOnly) ? globalThis.Boolean(object.inviteOnly) : false,
    };
  },

  toJSON(message: DuelListItem): unknown {
    const obj: any = {};
    if (message.duelId !== undefined) {
      obj.duelId = DuelId.toJSON(message.duelId);
    }
    if (message.status !== 0) {
      obj.status = gameStatusToJSON(message.status);
    }
    if (message.participants !== undefined) {
      obj.participants = DuelParticipants.toJSON(message.participants);
    }
    if (message.totalStakeValue !== undefined) {
      obj.totalStakeValue = TonAmount.toJSON(message.totalStakeValue);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.inviteOnly !== false) {
      obj.inviteOnly = message.inviteOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelListItem>, I>>(base?: I): DuelListItem {
    return DuelListItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelListItem>, I>>(object: I): DuelListItem {
    const message = createBaseDuelListItem();
    message.duelId = (object.duelId !== undefined && object.duelId !== null)
      ? DuelId.fromPartial(object.duelId)
      : undefined;
    message.status = object.status ?? 0;
    message.participants = (object.participants !== undefined && object.participants !== null)
      ? DuelParticipants.fromPartial(object.participants)
      : undefined;
    message.totalStakeValue = (object.totalStakeValue !== undefined && object.totalStakeValue !== null)
      ? TonAmount.fromPartial(object.totalStakeValue)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.inviteOnly = object.inviteOnly ?? false;
    return message;
  },
};

function createBaseDuelFilters(): DuelFilters {
  return {
    $type: "giftduels.duel.v1.DuelFilters",
    status: 0,
    inviteOnly: false,
    isCreator: false,
    isParticipant: false,
  };
}

export const DuelFilters: MessageFns<DuelFilters, "giftduels.duel.v1.DuelFilters"> = {
  $type: "giftduels.duel.v1.DuelFilters" as const,

  encode(message: DuelFilters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.inviteOnly !== false) {
      writer.uint32(24).bool(message.inviteOnly);
    }
    if (message.isCreator !== false) {
      writer.uint32(32).bool(message.isCreator);
    }
    if (message.isParticipant !== false) {
      writer.uint32(40).bool(message.isParticipant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelFilters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inviteOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isCreator = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isParticipant = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelFilters {
    return {
      $type: DuelFilters.$type,
      status: isSet(object.status) ? gameStatusFromJSON(object.status) : 0,
      inviteOnly: isSet(object.inviteOnly) ? globalThis.Boolean(object.inviteOnly) : false,
      isCreator: isSet(object.isCreator) ? globalThis.Boolean(object.isCreator) : false,
      isParticipant: isSet(object.isParticipant) ? globalThis.Boolean(object.isParticipant) : false,
    };
  },

  toJSON(message: DuelFilters): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = gameStatusToJSON(message.status);
    }
    if (message.inviteOnly !== false) {
      obj.inviteOnly = message.inviteOnly;
    }
    if (message.isCreator !== false) {
      obj.isCreator = message.isCreator;
    }
    if (message.isParticipant !== false) {
      obj.isParticipant = message.isParticipant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelFilters>, I>>(base?: I): DuelFilters {
    return DuelFilters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelFilters>, I>>(object: I): DuelFilters {
    const message = createBaseDuelFilters();
    message.status = object.status ?? 0;
    message.inviteOnly = object.inviteOnly ?? false;
    message.isCreator = object.isCreator ?? false;
    message.isParticipant = object.isParticipant ?? false;
    return message;
  },
};

function createBaseDuelSortOptions(): DuelSortOptions {
  return { $type: "giftduels.duel.v1.DuelSortOptions", field: 0, order: 0 };
}

export const DuelSortOptions: MessageFns<DuelSortOptions, "giftduels.duel.v1.DuelSortOptions"> = {
  $type: "giftduels.duel.v1.DuelSortOptions" as const,

  encode(message: DuelSortOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== 0) {
      writer.uint32(8).int32(message.field);
    }
    if (message.order !== 0) {
      writer.uint32(16).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuelSortOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuelSortOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.field = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuelSortOptions {
    return {
      $type: DuelSortOptions.$type,
      field: isSet(object.field) ? duelSortFieldFromJSON(object.field) : 0,
      order: isSet(object.order) ? sortOrderFromJSON(object.order) : 0,
    };
  },

  toJSON(message: DuelSortOptions): unknown {
    const obj: any = {};
    if (message.field !== 0) {
      obj.field = duelSortFieldToJSON(message.field);
    }
    if (message.order !== 0) {
      obj.order = sortOrderToJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuelSortOptions>, I>>(base?: I): DuelSortOptions {
    return DuelSortOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuelSortOptions>, I>>(object: I): DuelSortOptions {
    const message = createBaseDuelSortOptions();
    message.field = object.field ?? 0;
    message.order = object.order ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
